//! Generic inference runtime contract root.

pub const types = @import("types.zig");
pub const allocator = @import("allocator.zig");

pub const Opcode = types.Opcode;
pub const RegisterRef = types.RegisterRef;
pub const WeightRef = types.WeightRef;
pub const WeightBinding = types.WeightBinding;
pub const StateLifecycle = types.StateLifecycle;
pub const StateLifecycleAction = types.StateLifecycleAction;
pub const StateLifecyclePolicy = types.StateLifecyclePolicy;
pub const StateDescriptor = types.StateDescriptor;
pub const StateBlockId = types.StateBlockId;
pub const Instruction = types.Instruction;
pub const ExecutionPlan = types.ExecutionPlan;
pub const LivenessMap = types.LivenessMap;
pub const PlanDiagnosticLevel = types.PlanDiagnosticLevel;
pub const PlanDiagnostic = types.PlanDiagnostic;
pub const CompiledPlan = types.CompiledPlan;
pub const PhysicalBufferSpec = types.PhysicalBufferSpec;
pub const PhysicalMapping = types.PhysicalMapping;
pub const TensorHandle = types.TensorHandle;
pub const TensorLayout = types.TensorLayout;
pub const TensorViewDesc = types.TensorViewDesc;
pub const StateBlockHandle = types.StateBlockHandle;
pub const OpaqueStateRef = types.OpaqueStateRef;
pub const ParamBlock = types.ParamBlock;
pub const ExecutionMode = types.ExecutionMode;
pub const DispatchCounters = types.DispatchCounters;
pub const Workspace = types.Workspace;
pub const ExecutionContext = types.ExecutionContext;
pub const KernelAdapterFn = types.KernelAdapterFn;
pub const AdapterTable = types.AdapterTable;
pub const AdapterCapability = types.AdapterCapability;
pub const AdapterCapabilities = types.AdapterCapabilities;
pub const KernelWeightBindingName = types.KernelWeightBindingName;

pub const registerFromIndex = types.registerFromIndex;
pub const registerToIndex = types.registerToIndex;
pub const validateTensorViewDesc = types.validateTensorViewDesc;
pub const validateExecutionContext = types.validateExecutionContext;
pub const recordExecutionDispatch = types.recordExecutionDispatch;
pub const validateBatchCapability = types.validateBatchCapability;
pub const stateLifecyclePolicy = types.stateLifecyclePolicy;
pub const validateStateLifecycleAction = types.validateStateLifecycleAction;
pub const shouldZeroStateForLifecycleAction = types.shouldZeroStateForLifecycleAction;
pub const validateParamBlockAbi = types.validateParamBlockAbi;
pub const validateExecutionPlan = types.validateExecutionPlan;
pub const validateExecutionPlanForBlockKind = types.validateExecutionPlanForBlockKind;
pub const validateCompiledPlan = types.validateCompiledPlan;
pub const planFinalOutputRegister = types.planFinalOutputRegister;
pub const stateBlockIdForOpcode = types.stateBlockIdForOpcode;
pub const requiredStateBlockIdForOpcode = types.requiredStateBlockIdForOpcode;
pub const expectedKernelWeightSlots = types.expectedKernelWeightSlots;
pub const expectedWeightRefCount = types.expectedWeightRefCount;
pub const kernel_weight_binding_prefix = types.kernel_weight_binding_prefix;
pub const parseKernelWeightBindingName = types.parseKernelWeightBindingName;
pub const ParamDecoder = types.ParamDecoder;
pub const encodeLayerOpParam = types.encodeLayerOpParam;
pub const instructionWeightBindingName = types.instructionWeightBindingName;
pub const instructionSingleWeightBindingName = types.instructionSingleWeightBindingName;
pub const decodeInstructionLayerOp = types.decodeInstructionLayerOp;
pub const findStateBlock = types.findStateBlock;
pub const stateValueFromBlock = types.stateValueFromBlock;
pub const findStateValue = types.findStateValue;
pub const findStateDescriptor = types.findStateDescriptor;
pub const requireInstructionStateBlock = types.requireInstructionStateBlock;
pub const requireInstructionStateBlockForPlan = types.requireInstructionStateBlockForPlan;
pub const validateStateBlocksForDescriptors = types.validateStateBlocksForDescriptors;
pub const blockKindSupportsState = types.blockKindSupportsState;
pub const opcodeStateCompatibleWithBlockKind = types.opcodeStateCompatibleWithBlockKind;
pub const LayerProgramStateMismatch = types.LayerProgramStateMismatch;
pub const UnsupportedLayerProgramOpcode = types.UnsupportedLayerProgramOpcode;
pub const UnsupportedInstructionOpcode = types.UnsupportedInstructionOpcode;
pub const LayerProgramCompatibilityIssue = types.LayerProgramCompatibilityIssue;
pub const firstLayerProgramStateMismatch = types.firstLayerProgramStateMismatch;
pub const firstUnsupportedLayerProgramOpcode = types.firstUnsupportedLayerProgramOpcode;
pub const firstUnsupportedInstructionOpcode = types.firstUnsupportedInstructionOpcode;
pub const firstLayerProgramCompatibilityIssue = types.firstLayerProgramCompatibilityIssue;
pub const assertAdapterTableCoverage = types.assertAdapterTableCoverage;
pub const defaultStateDescriptor = types.defaultStateDescriptor;
pub const planHasStateDescriptor = types.planHasStateDescriptor;
pub const stateDescriptorIndex = types.stateDescriptorIndex;
pub const stateDescriptorSlicesEqual = types.stateDescriptorSlicesEqual;
pub const appendUniqueStateDescriptor = types.appendUniqueStateDescriptor;
pub const appendUniquePlanStateDescriptors = types.appendUniquePlanStateDescriptors;
pub const BuiltinStateFlags = types.BuiltinStateFlags;
pub const collectBuiltinStateFlags = types.collectBuiltinStateFlags;
pub const planUsesInstructionWeights = types.planUsesInstructionWeights;
pub const validatePlanWithoutInstructionWeights = types.validatePlanWithoutInstructionWeights;
pub const param_block_abi_version_v1 = types.param_block_abi_version_v1;
pub const max_param_block_data_bytes_v1 = types.max_param_block_data_bytes_v1;
pub const tensor_view_rank_cap_v1 = types.tensor_view_rank_cap_v1;
pub const RegisterBufferSpec = allocator.RegisterBufferSpec;
pub const buildPhysicalMappingLinearScan = allocator.buildPhysicalMappingLinearScan;
pub const deinitPhysicalMapping = allocator.deinitPhysicalMapping;
