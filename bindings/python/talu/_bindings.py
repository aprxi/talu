"""
FFI bindings for library loading, error handling, and error code mapping.

Justification: Provides CDLL library loading, ABI version handshake, signature
refinement for error API, thread-local error buffer management, and error code
to exception mapping. These bootstrap operations must use ctypes directly
before _native.py can be used.
"""

import ctypes
import threading
from pathlib import Path
from typing import Any

from ._native import setup_signatures
from .exceptions import (
    ConvertError,
    EmptyPromptError,
    GenerationError,
    IOError,
    ModelError,
    ModelNotFoundError,
    ResourceError,
    StorageError,
    TaluError,
    TemplateError,
    TemplateNotFoundError,
    TemplateSyntaxError,
    TemplateUndefinedError,
    TokenizerError,
    ValidationError,
)

# =============================================================================
# Library Loading
# =============================================================================


def _find_library_path() -> Path:
    """Find the talu shared library.

    The library should be bundled at talu/libtalu.{so,dylib,dll}.
    Build with 'zig build release -Drelease' to copy library to Python package.
    """
    here = Path(__file__).parent

    for ext in [".so", ".dylib", ".dll"]:
        bundled = here / f"libtalu{ext}"
        if bundled.exists():
            return bundled

    raise FileNotFoundError(  # pragma: no cover
        "Could not find talu library. "
        "Run 'zig build release -Drelease' from the repository root first."
    )


# Load library
_lib_path = _find_library_path()
_lib = ctypes.CDLL(str(_lib_path))


# =============================================================================
# Auto-Generated Signature Setup
# =============================================================================
# This sets up argtypes/restype for ALL C API functions at once.
# Generated by: zig build gen-bindings
# Source: core/src/capi/*.zig
setup_signatures(_lib)


# =============================================================================
# ABI Version Handshake - Fail Fast on Binary Mismatch
# =============================================================================
#
# This check runs ONCE at import time. If the Python package was built against
# a different version of the C-API than the loaded library, we fail immediately
# with a clear error instead of risking memory corruption/segfaults later.
#
# IMPORTANT: When bumping ABI_VERSION in Zig (core/src/lib.zig), also bump here.

EXPECTED_ABI_VERSION = 1

# Setup signature for version check
_lib.talu_get_abi_version.argtypes = []
_lib.talu_get_abi_version.restype = ctypes.c_int32

# Perform the handshake
_actual_abi_version = _lib.talu_get_abi_version()
if _actual_abi_version != EXPECTED_ABI_VERSION:  # pragma: no cover
    raise ImportError(
        f"Binary ABI mismatch! "
        f"talu Python package expects ABI v{EXPECTED_ABI_VERSION}, "
        f"but libtalu shared library reports v{_actual_abi_version}. "
        f"Library path: {_lib_path}\n"
        "Please reinstall the package or rebuild the library with 'make' or 'zig build'."
    )


# =============================================================================
# Error API Signature Refinement
# =============================================================================
# Most error API signatures are set by _native.py. We only override
# talu_take_last_error to use POINTER(c_int32) for out_code instead of c_void_p,
# which provides better type safety when passing ctypes.byref().

_lib.talu_take_last_error.argtypes = [
    ctypes.c_void_p,  # buf (writable, nullable)
    ctypes.c_size_t,  # buf_size
    ctypes.POINTER(ctypes.c_int32),  # out_code - refined from c_void_p
]

# Cache the recommended buffer size
_ERROR_BUF_SIZE: int | None = None


def get_lib() -> ctypes.CDLL:
    """Get the library handle."""
    return _lib


def get_error_buf_size() -> int:
    """Get the recommended buffer size for error messages."""
    global _ERROR_BUF_SIZE
    if _ERROR_BUF_SIZE is None:
        _ERROR_BUF_SIZE = _lib.talu_error_buf_size()
    assert _ERROR_BUF_SIZE is not None
    return _ERROR_BUF_SIZE


def get_last_error() -> str | None:
    """
    Get the last error message from the C library.

    The Zig core uses thread-local storage for detailed error messages.
    Call this after a C API function returns an error indicator (null, False, etc.)
    to get the detailed error message.

    Returns
    -------
    str or None
        The error message, or None if no error is set.
    """
    error_ptr = _lib.talu_last_error()
    if error_ptr:
        return error_ptr.decode("utf-8")
    return None


# Thread-local storage for error buffers
_thread_local = threading.local()


def _get_error_buf() -> tuple[ctypes.Array, int]:
    """Get thread-local error buffer and size, creating if needed."""
    if not hasattr(_thread_local, "error_buf"):
        buf_size = get_error_buf_size()
        _thread_local.error_buf = ctypes.create_string_buffer(buf_size)
        _thread_local.buf_size = buf_size
    return _thread_local.error_buf, _thread_local.buf_size


def take_last_error() -> tuple[int, str | None]:
    """
    Atomically retrieve error code and message, then clear.

    This is the preferred way to retrieve errors from the C API.
    It atomically copies the error state and clears it in one operation.

    Thread-safe: each thread has its own buffer.

    Returns
    -------
    tuple[int, str | None]
        A tuple of (error_code, error_message). Message is None if no error.
    """
    error_buf, buf_size = _get_error_buf()
    code = ctypes.c_int32()

    # Pass buffer address as void pointer
    length = _lib.talu_take_last_error(ctypes.addressof(error_buf), buf_size, ctypes.byref(code))

    if code.value == 0:
        return (0, None)

    # Use returned length, not .value (which stops at first NUL)
    message = error_buf.raw[:length].decode("utf-8", errors="replace") if length > 0 else None
    return (code.value, message)


def clear_error() -> None:
    """Clear the last error message."""
    _lib.talu_clear_error()


# =============================================================================
# Pointer Helpers
# =============================================================================


def cast_to_void_p(callback: Any) -> ctypes.c_void_p:
    """Cast a ctypes callback to c_void_p for passing to C API."""
    return ctypes.cast(callback, ctypes.c_void_p)


def null_void_p() -> ctypes.c_void_p:
    """Return a null c_void_p pointer."""
    return ctypes.c_void_p(0)


def read_c_string(ptr: Any) -> bytes | None:
    """Read a null-terminated C string from a pointer.

    Args:
        ptr: A pointer value (c_void_p, int, or struct field containing pointer).

    Returns
    -------
        The string bytes, or None if the C string itself is empty.

    Raises
    ------
        TaluError: If ptr is null/zero (internal error).
    """
    # Handle c_void_p objects
    if hasattr(ptr, "value"):
        ptr = ptr.value
    if not ptr:  # pragma: no cover - internal callers must pass valid pointers
        raise TaluError("unexpected null pointer in read_c_string", code="INTERNAL_ERROR")
    return ctypes.cast(ptr, ctypes.c_char_p).value


def read_buffer(ptr: Any, length: int) -> bytes:
    """Read a byte buffer of known length from a pointer.

    Args:
        ptr: A pointer value (c_void_p, int, or struct field containing pointer).
        length: Number of bytes to read.

    Returns
    -------
        The buffer contents as bytes.
    """
    return ctypes.string_at(ptr, length)


# =============================================================================
# Error Code to Exception Mapping
# =============================================================================

# Map Zig integer codes to (Exception class, string code)
# String codes are stable and should be used for programmatic error handling
ERROR_MAP: dict[int, tuple[type[TaluError], str]] = {
    # Model errors (100-199)
    100: (ModelNotFoundError, "MODEL_NOT_FOUND"),
    101: (ModelError, "MODEL_INVALID_FORMAT"),
    102: (ModelError, "MODEL_UNSUPPORTED_ARCHITECTURE"),
    103: (ModelError, "MODEL_CONFIG_MISSING"),
    104: (ModelError, "MODEL_WEIGHTS_MISSING"),
    105: (ModelError, "MODEL_WEIGHTS_CORRUPTED"),
    # Tokenizer errors (200-299)
    200: (TokenizerError, "TOKENIZER_NOT_FOUND"),
    201: (TokenizerError, "TOKENIZER_INVALID_FORMAT"),
    202: (TokenizerError, "TOKENIZER_ENCODE_FAILED"),
    203: (TokenizerError, "TOKENIZER_DECODE_FAILED"),
    # Generation errors (300-399)
    300: (GenerationError, "GENERATION_FAILED"),
    301: (EmptyPromptError, "GENERATION_EMPTY_PROMPT"),
    302: (GenerationError, "GENERATION_CONTEXT_OVERFLOW"),
    303: (GenerationError, "GENERATION_INVALID_PARAMS"),
    # Conversion errors (400-499)
    400: (ConvertError, "CONVERT_FAILED"),
    401: (ConvertError, "CONVERT_UNSUPPORTED_FORMAT"),
    402: (ConvertError, "CONVERT_ALREADY_QUANTIZED"),
    403: (ConvertError, "CONVERT_OUTPUT_EXISTS"),
    # I/O errors (500-599)
    500: (IOError, "IO_FILE_NOT_FOUND"),
    501: (IOError, "IO_PERMISSION_DENIED"),
    502: (IOError, "IO_READ_FAILED"),
    503: (IOError, "IO_WRITE_FAILED"),
    504: (IOError, "IO_NETWORK_FAILED"),
    # Template errors (600-699)
    600: (TemplateSyntaxError, "TEMPLATE_SYNTAX_ERROR"),
    601: (TemplateUndefinedError, "TEMPLATE_UNDEFINED_VAR"),
    602: (TemplateError, "TEMPLATE_TYPE_ERROR"),
    603: (TemplateError, "TEMPLATE_RENDER_FAILED"),
    604: (TemplateNotFoundError, "TEMPLATE_NOT_FOUND"),
    605: (TemplateError, "TEMPLATE_INVALID_JSON"),
    606: (TemplateError, "TEMPLATE_RAISE_EXCEPTION"),
    # Storage errors (700-799)
    700: (StorageError, "STORAGE_ERROR"),
    # System errors (900-999)
    900: (TaluError, "RESOURCE_OOM"),  # Special case: MemoryError
    901: (ValidationError, "INVALID_ARGUMENT"),
    902: (ValidationError, "INVALID_HANDLE"),
    903: (ValidationError, "AMBIGUOUS_BACKEND"),
    904: (ValidationError, "UNSUPPORTED_ABI_VERSION"),
    905: (ResourceError, "RESOURCE_EXHAUSTED"),
    999: (TaluError, "INTERNAL_ERROR"),
}


def check(code: int, context: dict[str, Any] | None = None) -> None:
    """
    Check error code and raise appropriate exception.

    Call immediately after any C API function that returns an error code.
    Uses talu_take_last_error() to atomically retrieve message and clear.

    Args:
        code: Error code from C API (0 = success)
        context: Optional context dict to include in exception details

    Raises
    ------
        TaluError: Appropriate subclass based on error code
        MemoryError: For out_of_memory (900)
    """
    if code == 0:
        return

    # Atomically get (code, message) and clear error state
    # Prefer the code from take_last_error() as it's atomically paired with message
    taken_code, message = take_last_error()

    # Use taken_code if available, fall back to passed code
    effective_code = taken_code if taken_code != 0 else code

    # Debug check: warn if codes mismatch (indicates something between call and check)
    if __debug__ and taken_code != 0 and taken_code != code and code >= 0:
        import warnings

        warnings.warn(
            f"Error code mismatch: function returned {code}, but TLS has {taken_code}. "
            "Did something call talu between the function and check()?",
            stacklevel=2,
        )

    # Provide default message if none available
    if not message:
        message = f"Unknown error (code {effective_code})"

    # Special case: OOM maps to Python's built-in MemoryError
    if effective_code == 900:
        raise MemoryError(message)

    # Find appropriate exception class and string code
    # Strict one-path: every Zig code MUST be explicitly mapped. No range fallback.
    mapping = ERROR_MAP.get(effective_code)
    if mapping is not None:
        error_class, string_code = mapping
    else:
        # Unmapped code = drift between Zig and Python bindings.
        # This is a bug that must be fixed by adding the code to ERROR_MAP.
        error_class = TaluError
        string_code = "UNMAPPED_ERROR"

    # Build details dict
    details = context.copy() if context else {}
    details["zig_code"] = effective_code

    raise error_class(message, code=string_code, details=details, original_code=effective_code)
