// =============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
//
// Generated by: zig build gen-bindings-rust
// Source:        core/src/capi/*.zig
// Generator:     core/tests/helpers/gen_bindings_rust.zig
//
// Any manual edits WILL BE LOST on the next regeneration.
// To add safe wrappers, edit the generator template instead.
// =============================================================================

//! Low-level FFI bindings for libtalu.
//!
//! This crate provides raw, unsafe bindings to the C API of libtalu.
//! For a safe, idiomatic Rust API, use the `talu` crate instead.

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(clippy::missing_safety_doc)]

use std::os::raw::{c_char, c_int, c_void};

// =============================================================================
// Enums
// =============================================================================

/// Source: core/src/capi/router.zig
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum CPoolingStrategy {
    Last = 0,
    Mean = 1,
    First = 2,
}

impl From<u8> for CPoolingStrategy {
    fn from(value: u8) -> Self {
        match value {
            0 => CPoolingStrategy::Last,
            1 => CPoolingStrategy::Mean,
            2 => CPoolingStrategy::First,
            _ => CPoolingStrategy::First,
        }
    }
}

/// Source: core/src/converter/scheme.zig
#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Scheme {
    F16 = 4,
    Gaf432 = 10,
    Gaf464 = 11,
    Gaf4128 = 12,
    Gaf832 = 13,
    Gaf864 = 14,
    Gaf8128 = 15,
    Fp8E4m3 = 20,
    Fp8E5m2 = 21,
    Mxfp4 = 22,
    Nvfp4 = 23,
}

impl From<u32> for Scheme {
    fn from(value: u32) -> Self {
        match value {
            4 => Scheme::F16,
            10 => Scheme::Gaf432,
            11 => Scheme::Gaf464,
            12 => Scheme::Gaf4128,
            13 => Scheme::Gaf832,
            14 => Scheme::Gaf864,
            15 => Scheme::Gaf8128,
            20 => Scheme::Fp8E4m3,
            21 => Scheme::Fp8E5m2,
            22 => Scheme::Mxfp4,
            23 => Scheme::Nvfp4,
            _ => Scheme::Nvfp4,
        }
    }
}

/// Source: core/src/capi/db.zig
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum CItemType {
    Message = 0,
    FunctionCall = 1,
    FunctionCallOutput = 2,
    Reasoning = 3,
    ItemReference = 4,
    Unknown = 255,
}

impl From<u8> for CItemType {
    fn from(value: u8) -> Self {
        match value {
            0 => CItemType::Message,
            1 => CItemType::FunctionCall,
            2 => CItemType::FunctionCallOutput,
            3 => CItemType::Reasoning,
            4 => CItemType::ItemReference,
            255 => CItemType::Unknown,
            _ => CItemType::Unknown,
        }
    }
}

/// Source: core/src/router/capi_bridge.zig
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum CFinishReason {
    EosToken = 0,
    Length = 1,
    StopSequence = 2,
    ToolCalls = 3,
    ContentFilter = 4,
    Cancelled = 5,
}

impl From<u8> for CFinishReason {
    fn from(value: u8) -> Self {
        match value {
            0 => CFinishReason::EosToken,
            1 => CFinishReason::Length,
            2 => CFinishReason::StopSequence,
            3 => CFinishReason::ToolCalls,
            4 => CFinishReason::ContentFilter,
            5 => CFinishReason::Cancelled,
            _ => CFinishReason::Cancelled,
        }
    }
}

/// Source: core/src/capi/log.zig
#[repr(i32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum LogFormat {
    Json = 0,
    Human = 1,
}

impl From<i32> for LogFormat {
    fn from(value: i32) -> Self {
        match value {
            0 => LogFormat::Json,
            1 => LogFormat::Human,
            _ => LogFormat::Human,
        }
    }
}

/// Source: core/src/router/iterator.zig
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum BackendType {
    Local,
    Http,
}

impl From<u8> for BackendType {
    fn from(value: u8) -> Self {
        match value {
            _ => BackendType::Http,
        }
    }
}

/// Source: core/src/capi/progress.zig
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum ProgressAction {
    Add = 0,
    Update = 1,
    Complete = 2,
}

impl From<u8> for ProgressAction {
    fn from(value: u8) -> Self {
        match value {
            0 => ProgressAction::Add,
            1 => ProgressAction::Update,
            2 => ProgressAction::Complete,
            _ => ProgressAction::Complete,
        }
    }
}

/// Source: core/src/capi/error_codes.zig
#[repr(i32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum ErrorCode {
    Ok = 0,
    ModelNotFound = 100,
    ModelInvalidFormat = 101,
    ModelUnsupportedArchitecture = 102,
    ModelConfigMissing = 103,
    ModelWeightsMissing = 104,
    ModelWeightsCorrupted = 105,
    TokenizerNotFound = 200,
    TokenizerInvalidFormat = 201,
    TokenizerEncodeFailed = 202,
    TokenizerDecodeFailed = 203,
    TokenizerInvalidTokenId = 204,
    GenerationFailed = 300,
    GenerationEmptyPrompt = 301,
    GenerationContextOverflow = 302,
    GenerationInvalidParams = 303,
    ConvertFailed = 400,
    ConvertUnsupportedFormat = 401,
    ConvertAlreadyQuantized = 402,
    ConvertOutputExists = 403,
    IoFileNotFound = 500,
    IoPermissionDenied = 501,
    IoReadFailed = 502,
    IoWriteFailed = 503,
    IoNetworkFailed = 504,
    TemplateSyntaxError = 600,
    TemplateUndefinedVar = 601,
    TemplateTypeError = 602,
    TemplateRenderFailed = 603,
    TemplateNotFound = 604,
    TemplateInvalidJson = 605,
    TemplateRaiseException = 606,
    StorageError = 700,
    ResourceBusy = 701,
    ItemNotFound = 702,
    SessionNotFound = 703,
    TagNotFound = 704,
    OutOfMemory = 900,
    InvalidArgument = 901,
    InvalidHandle = 902,
    AmbiguousBackend = 903,
    UnsupportedAbiVersion = 904,
    ResourceExhausted = 905,
    InternalError = 999,
}

impl From<i32> for ErrorCode {
    fn from(value: i32) -> Self {
        match value {
            0 => ErrorCode::Ok,
            100 => ErrorCode::ModelNotFound,
            101 => ErrorCode::ModelInvalidFormat,
            102 => ErrorCode::ModelUnsupportedArchitecture,
            103 => ErrorCode::ModelConfigMissing,
            104 => ErrorCode::ModelWeightsMissing,
            105 => ErrorCode::ModelWeightsCorrupted,
            200 => ErrorCode::TokenizerNotFound,
            201 => ErrorCode::TokenizerInvalidFormat,
            202 => ErrorCode::TokenizerEncodeFailed,
            203 => ErrorCode::TokenizerDecodeFailed,
            204 => ErrorCode::TokenizerInvalidTokenId,
            300 => ErrorCode::GenerationFailed,
            301 => ErrorCode::GenerationEmptyPrompt,
            302 => ErrorCode::GenerationContextOverflow,
            303 => ErrorCode::GenerationInvalidParams,
            400 => ErrorCode::ConvertFailed,
            401 => ErrorCode::ConvertUnsupportedFormat,
            402 => ErrorCode::ConvertAlreadyQuantized,
            403 => ErrorCode::ConvertOutputExists,
            500 => ErrorCode::IoFileNotFound,
            501 => ErrorCode::IoPermissionDenied,
            502 => ErrorCode::IoReadFailed,
            503 => ErrorCode::IoWriteFailed,
            504 => ErrorCode::IoNetworkFailed,
            600 => ErrorCode::TemplateSyntaxError,
            601 => ErrorCode::TemplateUndefinedVar,
            602 => ErrorCode::TemplateTypeError,
            603 => ErrorCode::TemplateRenderFailed,
            604 => ErrorCode::TemplateNotFound,
            605 => ErrorCode::TemplateInvalidJson,
            606 => ErrorCode::TemplateRaiseException,
            700 => ErrorCode::StorageError,
            701 => ErrorCode::ResourceBusy,
            702 => ErrorCode::ItemNotFound,
            703 => ErrorCode::SessionNotFound,
            704 => ErrorCode::TagNotFound,
            900 => ErrorCode::OutOfMemory,
            901 => ErrorCode::InvalidArgument,
            902 => ErrorCode::InvalidHandle,
            903 => ErrorCode::AmbiguousBackend,
            904 => ErrorCode::UnsupportedAbiVersion,
            905 => ErrorCode::ResourceExhausted,
            999 => ErrorCode::InternalError,
            _ => ErrorCode::InternalError,
        }
    }
}

/// Source: core/src/capi/db.zig
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum CMessageRole {
    System = 0,
    User = 1,
    Assistant = 2,
    Developer = 3,
    UnknownRole = 254,
    NotApplicable = 255,
}

impl From<u8> for CMessageRole {
    fn from(value: u8) -> Self {
        match value {
            0 => CMessageRole::System,
            1 => CMessageRole::User,
            2 => CMessageRole::Assistant,
            3 => CMessageRole::Developer,
            254 => CMessageRole::UnknownRole,
            255 => CMessageRole::NotApplicable,
            _ => CMessageRole::NotApplicable,
        }
    }
}

/// Source: core/src/capi/log.zig
#[repr(i32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum LogLevel {
    Trace = 1,
    Debug = 5,
    Info = 9,
    Warn = 13,
    Err = 17,
    Fatal = 21,
    Off = 255,
}

impl From<i32> for LogLevel {
    fn from(value: i32) -> Self {
        match value {
            1 => LogLevel::Trace,
            5 => LogLevel::Debug,
            9 => LogLevel::Info,
            13 => LogLevel::Warn,
            17 => LogLevel::Err,
            21 => LogLevel::Fatal,
            255 => LogLevel::Off,
            _ => LogLevel::Off,
        }
    }
}

/// Source: core/src/capi/db.zig
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum CStorageEventType {
    PutItems = 0,
    DeleteItem = 1,
    ClearItems = 2,
    PutSession = 3,
    BeginFork = 4,
    EndFork = 5,
}

impl From<u8> for CStorageEventType {
    fn from(value: u8) -> Self {
        match value {
            0 => CStorageEventType::PutItems,
            1 => CStorageEventType::DeleteItem,
            2 => CStorageEventType::ClearItems,
            3 => CStorageEventType::PutSession,
            4 => CStorageEventType::BeginFork,
            5 => CStorageEventType::EndFork,
            _ => CStorageEventType::EndFork,
        }
    }
}

/// Source: core/src/converter/scheme.zig
#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum QuantLevel {
    Q4 = 0,
    Q8 = 1,
    Q16 = 2,
}

impl From<u32> for QuantLevel {
    fn from(value: u32) -> Self {
        match value {
            0 => QuantLevel::Q4,
            1 => QuantLevel::Q8,
            2 => QuantLevel::Q16,
            _ => QuantLevel::Q16,
        }
    }
}

/// Source: core/src/capi/converter.zig
#[repr(i32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum QuantMethodEnum {
    None = 0,
    Gaffine = 1,
    Mxfp4 = 2,
    Native = 3,
}

impl From<i32> for QuantMethodEnum {
    fn from(value: i32) -> Self {
        match value {
            0 => QuantMethodEnum::None,
            1 => QuantMethodEnum::Gaffine,
            2 => QuantMethodEnum::Mxfp4,
            3 => QuantMethodEnum::Native,
            _ => QuantMethodEnum::Native,
        }
    }
}

/// Source: core/src/converter/scheme.zig
#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Platform {
    Cpu = 0,
    Metal = 1,
    Cuda = 2,
}

impl From<u32> for Platform {
    fn from(value: u32) -> Self {
        match value {
            0 => Platform::Cpu,
            1 => Platform::Metal,
            2 => Platform::Cuda,
            _ => Platform::Cuda,
        }
    }
}

// =============================================================================
// Structures
// =============================================================================

/// Source: core/src/capi/documents.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CCompactionStats {
    pub total_documents: usize,
    pub active_documents: usize,
    pub expired_documents: usize,
    pub deleted_documents: usize,
    pub tombstone_count: usize,
    pub delta_versions: usize,
    pub estimated_garbage_bytes: u64,
}

impl Default for CCompactionStats {
    fn default() -> Self {
        Self {
            total_documents: 0,
            active_documents: 0,
            expired_documents: 0,
            deleted_documents: 0,
            tombstone_count: 0,
            delta_versions: 0,
            estimated_garbage_bytes: 0,
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TokenizeResult {
    pub tokens: *const c_char,
    pub num_tokens: usize,
    pub error_msg: *const c_char,
}

impl Default for TokenizeResult {
    fn default() -> Self {
        Self {
            tokens: std::ptr::null(),
            num_tokens: 0,
            error_msg: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/db.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CSessionRecord {
    pub session_id: *const c_char,
    pub model: *const c_char,
    pub title: *const c_char,
    pub system_prompt: *const c_char,
    pub config_json: *const c_char,
    pub marker: *const c_char,
    pub parent_session_id: *const c_char,
    pub group_id: *const c_char,
    pub head_item_id: u64,
    pub ttl_ts: i64,
    pub metadata_json: *const c_char,
    pub tags_text: *const c_char,
    pub search_snippet: *const c_char,
    pub source_doc_id: *const c_char,
    pub created_at_ms: i64,
    pub updated_at_ms: i64,
}

impl Default for CSessionRecord {
    fn default() -> Self {
        Self {
            session_id: std::ptr::null(),
            model: std::ptr::null(),
            title: std::ptr::null(),
            system_prompt: std::ptr::null(),
            config_json: std::ptr::null(),
            marker: std::ptr::null(),
            parent_session_id: std::ptr::null(),
            group_id: std::ptr::null(),
            head_item_id: 0,
            ttl_ts: 0,
            metadata_json: std::ptr::null(),
            tags_text: std::ptr::null(),
            search_snippet: std::ptr::null(),
            source_doc_id: std::ptr::null(),
            created_at_ms: 0,
            updated_at_ms: 0,
        }
    }
}

/// Source: core/src/router/capi_bridge.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CRemoteModelInfo {
    pub id: *const c_char,
    pub object: *const c_char,
    pub created: i64,
    pub owned_by: *const c_char,
}

impl Default for CRemoteModelInfo {
    fn default() -> Self {
        Self {
            id: std::ptr::null(),
            object: std::ptr::null(),
            created: 0,
            owned_by: std::ptr::null(),
        }
    }
}

/// Source: core/src/converter/scheme.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ConvertOptions {
    pub scheme: Scheme,
    pub force: bool,
    pub offline: bool,
    pub destination: *const c_char,
    pub overrides: [OverrideRule; 32],
    pub num_overrides: u32,
    pub max_shard_size: u64,
    pub dry_run: bool,
    pub return_model_id: bool,
    pub platform: Platform,
    pub quant: QuantLevel,
    pub use_platform_quant: bool,
    pub progress_callback: *mut c_void,
    pub progress_user_data: *mut c_void,
}

impl Default for ConvertOptions {
    fn default() -> Self {
        Self {
            scheme: Scheme::from(0),
            force: false,
            offline: false,
            destination: std::ptr::null(),
            overrides: [OverrideRule::default(); 32],
            num_overrides: 0,
            max_shard_size: 0,
            dry_run: false,
            return_model_id: false,
            platform: Platform::from(0),
            quant: QuantLevel::from(0),
            use_platform_quant: false,
            progress_callback: std::ptr::null_mut(),
            progress_user_data: std::ptr::null_mut(),
        }
    }
}

/// Source: core/src/capi/provider.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CProviderInfo {
    pub name: *const c_char,
    pub default_endpoint: *const c_char,
    pub api_key_env: *const c_char,
}

impl Default for CProviderInfo {
    fn default() -> Self {
        Self {
            name: std::ptr::null(),
            default_endpoint: std::ptr::null(),
            api_key_env: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/validate.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValidateConfigC {
    pub allow_thinking: bool,
    pub max_thinking_tokens: usize,
    pub start_marker: *const c_char,
    pub soft_limit_ratio: f32,
    pub soft_limit_bias: f32,
}

impl Default for ValidateConfigC {
    fn default() -> Self {
        Self {
            allow_thinking: false,
            max_thinking_tokens: 0,
            start_marker: std::ptr::null(),
            soft_limit_ratio: 0.0,
            soft_limit_bias: 0.0,
        }
    }
}

/// Source: core/src/capi/blobs.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BlobGcStats {
    pub referenced_blob_count: usize,
    pub total_blob_files: usize,
    pub deleted_blob_files: usize,
    pub reclaimed_bytes: u64,
    pub invalid_reference_count: usize,
    pub skipped_invalid_entries: usize,
    pub skipped_recent_blob_files: usize,
}

impl Default for BlobGcStats {
    fn default() -> Self {
        Self {
            referenced_blob_count: 0,
            total_blob_files: 0,
            deleted_blob_files: 0,
            reclaimed_bytes: 0,
            invalid_reference_count: 0,
            skipped_invalid_entries: 0,
            skipped_recent_blob_files: 0,
        }
    }
}

/// Source: core/src/capi/responses.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CReasoningItem {
    pub content_count: usize,
    pub summary_count: usize,
    pub encrypted_content_ptr: *const u8,
    pub encrypted_content_len: usize,
}

impl Default for CReasoningItem {
    fn default() -> Self {
        Self {
            content_count: 0,
            summary_count: 0,
            encrypted_content_ptr: std::ptr::null(),
            encrypted_content_len: 0,
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TokenizeBytesResult {
    pub data: *const u8,
    pub data_len: usize,
    pub offsets: *const usize,
    pub num_tokens: usize,
    pub error_msg: *const c_char,
}

impl Default for TokenizeBytesResult {
    fn default() -> Self {
        Self {
            data: std::ptr::null(),
            data_len: 0,
            offsets: std::ptr::null(),
            num_tokens: 0,
            error_msg: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/file.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaluModelInputSpec {
    pub width: u32,
    pub height: u32,
    pub dtype: c_int,
    pub layout: c_int,
    pub normalize: c_int,
    pub fit_mode: c_int,
    pub filter: c_int,
    pub pad_r: u8,
    pub pad_g: u8,
    pub pad_b: u8,
    pub _reserved0: [u8; 5],
    pub max_input_bytes: usize,
    pub max_dimension: u32,
    pub max_pixels: u64,
    pub max_output_bytes: usize,
}

impl Default for TaluModelInputSpec {
    fn default() -> Self {
        Self {
            width: 0,
            height: 0,
            dtype: 0,
            layout: 0,
            normalize: 0,
            fit_mode: 0,
            filter: 0,
            pad_r: 0,
            pad_g: 0,
            pad_b: 0,
            _reserved0: [0; 5],
            max_input_bytes: 0,
            max_dimension: 0,
            max_pixels: 0,
            max_output_bytes: 0,
        }
    }
}

/// Source: core/src/capi/file.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaluModelBuffer {
    pub data: *const u8,
    pub len: usize,
    pub width: u32,
    pub height: u32,
    pub channels: u8,
    pub layout: c_int,
    pub dtype: c_int,
    pub _reserved: [u8; 6],
}

impl Default for TaluModelBuffer {
    fn default() -> Self {
        Self {
            data: std::ptr::null(),
            len: 0,
            width: 0,
            height: 0,
            channels: 0,
            layout: 0,
            dtype: 0,
            _reserved: [0; 6],
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TokenOffset {
    pub start: u32,
    pub end: u32,
}

impl Default for TokenOffset {
    fn default() -> Self {
        Self { start: 0, end: 0 }
    }
}

/// Source: core/src/capi/file.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaluImageResizeOptions {
    pub enabled: u8,
    pub out_w: u32,
    pub out_h: u32,
    pub fit_mode: c_int,
    pub filter: c_int,
    pub pad_r: u8,
    pub pad_g: u8,
    pub pad_b: u8,
    pub _reserved: [u8; 21],
}

impl Default for TaluImageResizeOptions {
    fn default() -> Self {
        Self {
            enabled: 0,
            out_w: 0,
            out_h: 0,
            fit_mode: 0,
            filter: 0,
            pad_r: 0,
            pad_g: 0,
            pad_b: 0,
            _reserved: [0; 21],
        }
    }
}

/// Source: core/src/capi/session.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GenerationConfigInfo {
    pub temperature: f32,
    pub top_k: usize,
    pub top_p: f32,
    pub do_sample: bool,
}

impl Default for GenerationConfigInfo {
    fn default() -> Self {
        Self {
            temperature: 0.0,
            top_k: 0,
            top_p: 0.0,
            do_sample: false,
        }
    }
}

/// Source: core/src/capi/documents.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CChangeRecord {
    pub seq_num: u64,
    pub doc_id: *const c_char,
    pub action: u8,
    pub timestamp_ms: i64,
    pub doc_type: *const c_char,
    pub title: *const c_char,
    pub _reserved: [u8; 7],
}

impl Default for CChangeRecord {
    fn default() -> Self {
        Self {
            seq_num: 0,
            doc_id: std::ptr::null(),
            action: 0,
            timestamp_ms: 0,
            doc_type: std::ptr::null(),
            title: std::ptr::null(),
            _reserved: [0; 7],
        }
    }
}

/// Source: core/src/capi/documents.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CSearchResult {
    pub doc_id: *const c_char,
    pub doc_type: *const c_char,
    pub title: *const c_char,
    pub snippet: *const c_char,
}

impl Default for CSearchResult {
    fn default() -> Self {
        Self {
            doc_id: std::ptr::null(),
            doc_type: std::ptr::null(),
            title: std::ptr::null(),
            snippet: std::ptr::null(),
        }
    }
}

/// Source: core/src/router/capi_bridge.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CLogitBiasEntry {
    pub token_id: u32,
    pub bias: f32,
}

impl Default for CLogitBiasEntry {
    fn default() -> Self {
        Self {
            token_id: 0,
            bias: 0.0,
        }
    }
}

/// Source: core/src/capi/xray.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TensorStats {
    pub count: u64,
    pub min: f32,
    pub max: f32,
    pub mean: f32,
    pub rms: f32,
    pub nan_count: u32,
    pub inf_count: u32,
}

impl Default for TensorStats {
    fn default() -> Self {
        Self {
            count: 0,
            min: 0.0,
            max: 0.0,
            mean: 0.0,
            rms: 0.0,
            nan_count: 0,
            inf_count: 0,
        }
    }
}

/// Source: core/src/capi/converter.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ModelInfo {
    pub vocab_size: c_int,
    pub hidden_size: c_int,
    pub num_layers: c_int,
    pub num_heads: c_int,
    pub num_kv_heads: c_int,
    pub intermediate_size: c_int,
    pub max_seq_len: c_int,
    pub head_dim: c_int,
    pub rope_theta: f32,
    pub norm_eps: f32,
    pub quant_bits: c_int,
    pub quant_group_size: c_int,
    pub quant_method: QuantMethodEnum,
    pub model_type: *const c_char,
    pub architecture: *const c_char,
    pub tie_word_embeddings: bool,
    pub use_gelu: bool,
    pub num_experts: c_int,
    pub experts_per_token: c_int,
    pub error_msg: *const c_char,
}

impl Default for ModelInfo {
    fn default() -> Self {
        Self {
            vocab_size: 0,
            hidden_size: 0,
            num_layers: 0,
            num_heads: 0,
            num_kv_heads: 0,
            intermediate_size: 0,
            max_seq_len: 0,
            head_dim: 0,
            rope_theta: 0.0,
            norm_eps: 0.0,
            quant_bits: 0,
            quant_group_size: 0,
            quant_method: QuantMethodEnum::from(0),
            model_type: std::ptr::null(),
            architecture: std::ptr::null(),
            tie_word_embeddings: false,
            use_gelu: false,
            num_experts: 0,
            experts_per_token: 0,
            error_msg: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EncodeOptions {
    pub add_bos: u8,
    pub add_eos: u8,
    pub truncation: u8,
    pub truncation_side: u8,
    pub _padding: [u8; 4],
    pub max_length: usize,
}

impl Default for EncodeOptions {
    fn default() -> Self {
        Self {
            add_bos: 0,
            add_eos: 0,
            truncation: 0,
            truncation_side: 0,
            _padding: [0; 4],
            max_length: 0,
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EosTokenResult {
    pub tokens: *const u32,
    pub num_tokens: usize,
}

impl Default for EosTokenResult {
    fn default() -> Self {
        Self {
            tokens: std::ptr::null(),
            num_tokens: 0,
        }
    }
}

/// Source: core/src/capi/plugins.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPluginInfo {
    pub plugin_id: *const c_char,
    pub plugin_dir: *const c_char,
    pub entry_path: *const c_char,
    pub manifest_json: *const c_char,
    pub is_directory: bool,
    pub _reserved: [u8; 7],
}

impl Default for CPluginInfo {
    fn default() -> Self {
        Self {
            plugin_id: std::ptr::null(),
            plugin_dir: std::ptr::null(),
            entry_path: std::ptr::null(),
            manifest_json: std::ptr::null(),
            is_directory: false,
            _reserved: [0; 7],
        }
    }
}

/// Source: core/src/capi/documents.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CDocumentSummary {
    pub doc_id: *const c_char,
    pub doc_type: *const c_char,
    pub title: *const c_char,
    pub updated_at_ms: i64,
    pub created_at_ms: i64,
    pub marker: *const c_char,
}

impl Default for CDocumentSummary {
    fn default() -> Self {
        Self {
            doc_id: std::ptr::null(),
            doc_type: std::ptr::null(),
            title: std::ptr::null(),
            updated_at_ms: 0,
            created_at_ms: 0,
            marker: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/responses.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CFunctionCallItem {
    pub name_ptr: *const c_char,
    pub call_id_ptr: *const c_char,
    pub arguments_ptr: *const u8,
    pub arguments_len: usize,
}

impl Default for CFunctionCallItem {
    fn default() -> Self {
        Self {
            name_ptr: std::ptr::null(),
            call_id_ptr: std::ptr::null(),
            arguments_ptr: std::ptr::null(),
            arguments_len: 0,
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DecodeOptionsC {
    pub skip_special_tokens: c_int,
}

impl Default for DecodeOptionsC {
    fn default() -> Self {
        Self {
            skip_special_tokens: 0,
        }
    }
}

/// Source: core/src/capi/responses.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CContentPart {
    pub content_type: u8,
    pub image_detail: u8,
    pub _padding: [u8; 6],
    pub data_ptr: *const u8,
    pub data_len: usize,
    pub secondary_ptr: *const u8,
    pub secondary_len: usize,
    pub tertiary_ptr: *const u8,
    pub tertiary_len: usize,
    pub quaternary_ptr: *const u8,
    pub quaternary_len: usize,
}

impl Default for CContentPart {
    fn default() -> Self {
        Self {
            content_type: 0,
            image_detail: 0,
            _padding: [0; 6],
            data_ptr: std::ptr::null(),
            data_len: 0,
            secondary_ptr: std::ptr::null(),
            secondary_len: 0,
            tertiary_ptr: std::ptr::null(),
            tertiary_len: 0,
            quaternary_ptr: std::ptr::null(),
            quaternary_len: 0,
        }
    }
}

/// Source: core/src/capi/responses.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CFunctionCallOutputItem {
    pub call_id_ptr: *const c_char,
    pub output_text_ptr: *const u8,
    pub output_text_len: usize,
    pub output_parts_count: usize,
    pub is_text_output: bool,
    pub _padding: [u8; 7],
}

impl Default for CFunctionCallOutputItem {
    fn default() -> Self {
        Self {
            call_id_ptr: std::ptr::null(),
            output_text_ptr: std::ptr::null(),
            output_text_len: 0,
            output_parts_count: 0,
            is_text_output: false,
            _padding: [0; 7],
        }
    }
}

/// Source: core/src/capi/responses.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CMessageItem {
    pub role: u8,
    pub _padding: [u8; 7],
    pub content_count: usize,
    pub raw_role_ptr: *const c_char,
}

impl Default for CMessageItem {
    fn default() -> Self {
        Self {
            role: 0,
            _padding: [0; 7],
            content_count: 0,
            raw_role_ptr: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/xray.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CapturedTensorInfo {
    pub point: u8,
    pub layer: u16,
    pub token: u32,
    pub position: u32,
    pub shape: [u32; 4],
    pub ndim: u8,
    pub dtype: u8,
    pub kernel_name: [u8; 48],
    pub stats: TensorStats,
    pub timestamp_ns: i64,
}

impl Default for CapturedTensorInfo {
    fn default() -> Self {
        Self {
            point: 0,
            layer: 0,
            token: 0,
            position: 0,
            shape: [0; 4],
            ndim: 0,
            dtype: 0,
            kernel_name: [0; 48],
            stats: TensorStats::default(),
            timestamp_ns: 0,
        }
    }
}

/// Source: core/src/capi/types.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OpenAICompatibleConfig {
    pub base_url: *const c_char,
    pub api_key: *const c_char,
    pub org_id: *const c_char,
    pub timeout_ms: c_int,
    pub max_retries: c_int,
    pub custom_headers_json: *const c_char,
    pub _reserved: [u8; 24],
}

impl Default for OpenAICompatibleConfig {
    fn default() -> Self {
        Self {
            base_url: std::ptr::null(),
            api_key: std::ptr::null(),
            org_id: std::ptr::null(),
            timeout_ms: 0,
            max_retries: 0,
            custom_headers_json: std::ptr::null(),
            _reserved: [0; 24],
        }
    }
}

/// Source: core/src/capi/db.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CStorageRecord {
    pub item_id: u64,
    pub session_id: *const c_char,
    pub item_type: u8,
    pub role: u8,
    pub status: u8,
    pub hidden: bool,
    pub pinned: bool,
    pub json_valid: bool,
    pub schema_valid: bool,
    pub repaired: bool,
    pub parent_item_id: u64,
    pub has_parent: bool,
    pub origin_item_id: u64,
    pub has_origin: bool,
    pub origin_session_id: *const c_char,
    pub finish_reason: *const c_char,
    pub prefill_ns: u64,
    pub generation_ns: u64,
    pub input_tokens: u32,
    pub output_tokens: u32,
    pub ttl_ts: i64,
    pub created_at_ms: i64,
    pub content_json: *const c_char,
    pub metadata_json: *const c_char,
    pub _reserved: [u8; 13],
}

impl Default for CStorageRecord {
    fn default() -> Self {
        Self {
            item_id: 0,
            session_id: std::ptr::null(),
            item_type: 0,
            role: 0,
            status: 0,
            hidden: false,
            pinned: false,
            json_valid: false,
            schema_valid: false,
            repaired: false,
            parent_item_id: 0,
            has_parent: false,
            origin_item_id: 0,
            has_origin: false,
            origin_session_id: std::ptr::null(),
            finish_reason: std::ptr::null(),
            prefill_ns: 0,
            generation_ns: 0,
            input_tokens: 0,
            output_tokens: 0,
            ttl_ts: 0,
            created_at_ms: 0,
            content_json: std::ptr::null(),
            metadata_json: std::ptr::null(),
            _reserved: [0; 13],
        }
    }
}

/// Source: core/src/capi/xray.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QueryResult {
    pub results: *mut CapturedTensorInfo,
    pub count: usize,
    pub error_msg: *const c_char,
}

impl Default for QueryResult {
    fn default() -> Self {
        Self {
            results: std::ptr::null_mut(),
            count: 0,
            error_msg: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/responses.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CItemReferenceItem {
    pub id_ptr: *const c_char,
}

impl Default for CItemReferenceItem {
    fn default() -> Self {
        Self {
            id_ptr: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/documents.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CStringList {
    pub items: *const c_char,
    pub count: usize,
    pub _arena: *mut c_void,
}

impl Default for CStringList {
    fn default() -> Self {
        Self {
            items: std::ptr::null(),
            count: 0,
            _arena: std::ptr::null_mut(),
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EncodeResult {
    pub ids: *const u32,
    pub offsets: *mut TokenOffset,
    pub attention_mask: *const u32,
    pub special_tokens_mask: *const u32,
    pub num_tokens: usize,
    pub error_msg: *const c_char,
}

impl Default for EncodeResult {
    fn default() -> Self {
        Self {
            ids: std::ptr::null(),
            offsets: std::ptr::null_mut(),
            attention_mask: std::ptr::null(),
            special_tokens_mask: std::ptr::null(),
            num_tokens: 0,
            error_msg: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/types.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaluCapabilities {
    pub abi_version: u32,
    pub struct_size: u32,
    pub streaming: u8,
    pub tool_calling: u8,
    pub logprobs: u8,
    pub embeddings: u8,
    pub json_schema: u8,
    pub _reserved: [u8; 32],
}

impl Default for TaluCapabilities {
    fn default() -> Self {
        Self {
            abi_version: 0,
            struct_size: 0,
            streaming: 0,
            tool_calling: 0,
            logprobs: 0,
            embeddings: 0,
            json_schema: 0,
            _reserved: [0; 32],
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SpecialTokensResult {
    pub bos_token_id: c_int,
    pub unk_token_id: c_int,
    pub pad_token_id: c_int,
}

impl Default for SpecialTokensResult {
    fn default() -> Self {
        Self {
            bos_token_id: 0,
            unk_token_id: 0,
            pad_token_id: 0,
        }
    }
}

/// Source: core/src/capi/documents.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CDocumentList {
    pub items: *mut CDocumentSummary,
    pub count: usize,
    pub has_more: bool,
    pub _arena: *mut c_void,
}

impl Default for CDocumentList {
    fn default() -> Self {
        Self {
            items: std::ptr::null_mut(),
            count: 0,
            has_more: false,
            _arena: std::ptr::null_mut(),
        }
    }
}

/// Source: core/src/capi/converter.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ConvertResult {
    pub output_path: *const c_char,
    pub error_msg: *const c_char,
    pub success: bool,
}

impl Default for ConvertResult {
    fn default() -> Self {
        Self {
            output_path: std::ptr::null(),
            error_msg: std::ptr::null(),
            success: false,
        }
    }
}

/// Source: core/src/converter/scheme.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OverrideRule {
    pub pattern: *const c_char,
    pub scheme: Scheme,
}

impl Default for OverrideRule {
    fn default() -> Self {
        Self {
            pattern: std::ptr::null(),
            scheme: Scheme::from(0),
        }
    }
}

/// Source: core/src/capi/types.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LocalConfig {
    pub gpu_layers: c_int,
    pub use_mmap: u8,
    pub num_threads: c_int,
    pub _reserved: [u8; 32],
}

impl Default for LocalConfig {
    fn default() -> Self {
        Self {
            gpu_layers: 0,
            use_mmap: 0,
            num_threads: 0,
            _reserved: [0; 32],
        }
    }
}

/// Source: core/src/capi/db.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CTagRecord {
    pub tag_id: *const c_char,
    pub name: *const c_char,
    pub color: *const c_char,
    pub description: *const c_char,
    pub group_id: *const c_char,
    pub created_at_ms: i64,
    pub updated_at_ms: i64,
    pub _reserved: [u8; 8],
}

impl Default for CTagRecord {
    fn default() -> Self {
        Self {
            tag_id: std::ptr::null(),
            name: std::ptr::null(),
            color: std::ptr::null(),
            description: std::ptr::null(),
            group_id: std::ptr::null(),
            created_at_ms: 0,
            updated_at_ms: 0,
            _reserved: [0; 8],
        }
    }
}

/// Source: core/src/capi/responses.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ChatCreateOptions {
    pub offline: bool,
}

impl Default for ChatCreateOptions {
    fn default() -> Self {
        Self { offline: false }
    }
}

/// Source: core/src/capi/converter.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExecutionPlanInfo {
    pub matmul_kernel: *const c_char,
    pub attention_type: *const c_char,
    pub ffn_type: *const c_char,
    pub num_layers: c_int,
    pub hidden_size: c_int,
    pub num_heads: c_int,
    pub num_kv_heads: c_int,
    pub head_dim: c_int,
    pub num_experts: c_int,
    pub experts_per_token: c_int,
    pub quant_bits: c_int,
    pub quant_group_size: c_int,
    pub uses_gqa: bool,
    pub uses_moe: bool,
    pub uses_quantization: bool,
    pub uses_gelu: bool,
    pub is_supported: bool,
    pub error_msg: *const c_char,
}

impl Default for ExecutionPlanInfo {
    fn default() -> Self {
        Self {
            matmul_kernel: std::ptr::null(),
            attention_type: std::ptr::null(),
            ffn_type: std::ptr::null(),
            num_layers: 0,
            hidden_size: 0,
            num_heads: 0,
            num_kv_heads: 0,
            head_dim: 0,
            num_experts: 0,
            experts_per_token: 0,
            quant_bits: 0,
            quant_group_size: 0,
            uses_gqa: false,
            uses_moe: false,
            uses_quantization: false,
            uses_gelu: false,
            is_supported: false,
            error_msg: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BatchEncodeResult {
    pub ids: *const u32,
    pub offsets: *const usize,
    pub total_tokens: usize,
    pub num_sequences: usize,
    pub error_msg: *const c_char,
}

impl Default for BatchEncodeResult {
    fn default() -> Self {
        Self {
            ids: std::ptr::null(),
            offsets: std::ptr::null(),
            total_tokens: 0,
            num_sequences: 0,
            error_msg: std::ptr::null(),
        }
    }
}

/// Source: core/src/router/capi_bridge.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CGenerateConfig {
    pub max_tokens: usize,
    pub temperature: f32,
    pub top_k: usize,
    pub top_p: f32,
    pub min_p: f32,
    pub repetition_penalty: f32,
    pub stop_sequences: *const c_char,
    pub stop_sequence_count: usize,
    pub logit_bias: *const CLogitBiasEntry,
    pub logit_bias_count: usize,
    pub seed: u64,
    pub template_override: *const c_char,
    pub extra_context_json: *const c_char,
    pub tools_json: *const c_char,
    pub tool_choice: *const c_char,
    pub stop_flag: *mut c_void,
    pub extra_body_json: *const c_char,
    pub raw_output: u8,
    pub prefill_progress_fn: *mut c_void,
    pub prefill_progress_data: *mut c_void,
}

impl Default for CGenerateConfig {
    fn default() -> Self {
        Self {
            max_tokens: 0,
            temperature: 0.0,
            top_k: 0,
            top_p: 0.0,
            min_p: 0.0,
            repetition_penalty: 0.0,
            stop_sequences: std::ptr::null(),
            stop_sequence_count: 0,
            logit_bias: std::ptr::null(),
            logit_bias_count: 0,
            seed: 0,
            template_override: std::ptr::null(),
            extra_context_json: std::ptr::null(),
            tools_json: std::ptr::null(),
            tool_choice: std::ptr::null(),
            stop_flag: std::ptr::null_mut(),
            extra_body_json: std::ptr::null(),
            raw_output: 0,
            prefill_progress_fn: std::ptr::null_mut(),
            prefill_progress_data: std::ptr::null_mut(),
        }
    }
}

/// Source: core/src/capi/file.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaluFileTransformOptions {
    pub resize_enabled: u8,
    pub out_w: u32,
    pub out_h: u32,
    pub fit_mode: c_int,
    pub filter: c_int,
    pub pad_r: u8,
    pub pad_g: u8,
    pub pad_b: u8,
    pub output_format: c_int,
    pub jpeg_quality: u8,
    pub max_input_bytes: usize,
    pub max_dimension: u32,
    pub max_pixels: u64,
    pub max_output_bytes: usize,
    pub _reserved: [u8; 14],
}

impl Default for TaluFileTransformOptions {
    fn default() -> Self {
        Self {
            resize_enabled: 0,
            out_w: 0,
            out_h: 0,
            fit_mode: 0,
            filter: 0,
            pad_r: 0,
            pad_g: 0,
            pad_b: 0,
            output_format: 0,
            jpeg_quality: 0,
            max_input_bytes: 0,
            max_dimension: 0,
            max_pixels: 0,
            max_output_bytes: 0,
            _reserved: [0; 14],
        }
    }
}

/// Source: core/src/capi/progress.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ProgressUpdate {
    pub line_id: u8,
    pub action: ProgressAction,
    pub current: u64,
    pub total: u64,
    pub label: *const c_char,
    pub message: *const c_char,
    pub unit: *const c_char,
}

impl Default for ProgressUpdate {
    fn default() -> Self {
        Self {
            line_id: 0,
            action: ProgressAction::from(0),
            current: 0,
            total: 0,
            label: std::ptr::null(),
            message: std::ptr::null(),
            unit: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/documents.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CChangeList {
    pub items: *mut CChangeRecord,
    pub count: usize,
    pub next_seq: u64,
    pub _arena: *mut c_void,
}

impl Default for CChangeList {
    fn default() -> Self {
        Self {
            items: std::ptr::null_mut(),
            count: 0,
            next_seq: 0,
            _arena: std::ptr::null_mut(),
        }
    }
}

/// Source: core/src/capi/plugins.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPluginList {
    pub items: *mut CPluginInfo,
    pub count: usize,
    pub _arena: *mut c_void,
}

impl Default for CPluginList {
    fn default() -> Self {
        Self {
            items: std::ptr::null_mut(),
            count: 0,
            _arena: std::ptr::null_mut(),
        }
    }
}

/// Source: core/src/capi/session.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SamplingParams {
    pub strategy: u32,
    pub temperature: f32,
    pub top_k: u32,
    pub top_p: f32,
    pub min_p: f32,
    pub repetition_penalty: f32,
    pub seed: u64,
}

impl Default for SamplingParams {
    fn default() -> Self {
        Self {
            strategy: 0,
            temperature: 0.0,
            top_k: 0,
            top_p: 0.0,
            min_p: 0.0,
            repetition_penalty: 0.0,
            seed: 0,
        }
    }
}

/// Source: core/src/capi/types.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub union BackendUnion {
    pub local: LocalConfig,
    pub openai_compat: OpenAICompatibleConfig,
}

/// Source: core/src/capi/validate.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemanticViolationC {
    pub path: *const c_char,
    pub message: *const c_char,
    pub constraint_type: c_int,
}

impl Default for SemanticViolationC {
    fn default() -> Self {
        Self {
            path: std::ptr::null(),
            message: std::ptr::null(),
            constraint_type: 0,
        }
    }
}

/// Source: core/src/capi/router.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BackendCreateOptions {
    pub progress_callback: *mut c_void,
    pub progress_user_data: *mut c_void,
}

impl Default for BackendCreateOptions {
    fn default() -> Self {
        Self {
            progress_callback: std::ptr::null_mut(),
            progress_user_data: std::ptr::null_mut(),
        }
    }
}

/// Source: core/src/capi/types.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaluModelSpec {
    pub abi_version: u32,
    pub struct_size: u32,
    pub ref_: *const c_char,
    pub backend_type_raw: c_int,
    pub backend_config: BackendUnion,
}

impl Default for TaluModelSpec {
    fn default() -> Self {
        Self {
            abi_version: 0,
            struct_size: 0,
            ref_: std::ptr::null(),
            backend_type_raw: 0,
            backend_config: unsafe { std::mem::zeroed() },
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PaddedTensorOptions {
    pub pad_id: u32,
    pub padding_side: u8,
    pub max_length: usize,
    pub truncate: bool,
    pub return_attention_mask: bool,
}

impl Default for PaddedTensorOptions {
    fn default() -> Self {
        Self {
            pad_id: 0,
            padding_side: 0,
            max_length: 0,
            truncate: false,
            return_attention_mask: false,
        }
    }
}

/// Source: core/src/capi/repository.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DownloadOptions {
    pub token: *const c_char,
    pub progress_callback: *mut c_void,
    pub user_data: *mut c_void,
    pub force: bool,
    pub endpoint_url: *const c_char,
    pub skip_weights: bool,
}

impl Default for DownloadOptions {
    fn default() -> Self {
        Self {
            token: std::ptr::null(),
            progress_callback: std::ptr::null_mut(),
            user_data: std::ptr::null_mut(),
            force: false,
            endpoint_url: std::ptr::null(),
            skip_weights: false,
        }
    }
}

/// Source: core/src/router/capi_bridge.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CToolCallRef {
    pub item_index: usize,
    pub call_id: *const c_char,
    pub name: *const c_char,
    pub arguments: *const c_char,
}

impl Default for CToolCallRef {
    fn default() -> Self {
        Self {
            item_index: 0,
            call_id: std::ptr::null(),
            name: std::ptr::null(),
            arguments: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/file.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaluImageConvertOptions {
    pub format: c_int,
    pub alpha_mode: c_int,
    pub alpha_background_r: u8,
    pub alpha_background_g: u8,
    pub alpha_background_b: u8,
    pub resize: TaluImageResizeOptions,
    pub max_input_bytes: usize,
    pub max_dimension: u32,
    pub max_pixels: u64,
    pub max_output_bytes: usize,
}

impl Default for TaluImageConvertOptions {
    fn default() -> Self {
        Self {
            format: 0,
            alpha_mode: 0,
            alpha_background_r: 0,
            alpha_background_g: 0,
            alpha_background_b: 0,
            resize: TaluImageResizeOptions::default(),
            max_input_bytes: 0,
            max_dimension: 0,
            max_pixels: 0,
            max_output_bytes: 0,
        }
    }
}

/// Source: core/src/capi/db.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CStorageEvent {
    pub event_type: CStorageEventType,
    pub _pad: [u8; 7],
    pub items: *const CStorageRecord,
    pub items_count: usize,
    pub session: CSessionRecord,
    pub deleted_item_id: u64,
    pub deleted_at_ms: i64,
    pub cleared_at_ms: i64,
    pub keep_context: bool,
    pub fork_id: u64,
    pub fork_session_id: *const c_char,
    pub _reserved: [u8; 7],
}

impl Default for CStorageEvent {
    fn default() -> Self {
        Self {
            event_type: CStorageEventType::from(0),
            _pad: [0; 7],
            items: std::ptr::null(),
            items_count: 0,
            session: CSessionRecord::default(),
            deleted_item_id: 0,
            deleted_at_ms: 0,
            cleared_at_ms: 0,
            keep_context: false,
            fork_id: 0,
            fork_session_id: std::ptr::null(),
            _reserved: [0; 7],
        }
    }
}

/// Source: core/src/router/capi_bridge.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GenerateContentPart {
    pub content_type: u8,
    pub data_ptr: *const u8,
    pub data_len: usize,
    pub mime_ptr: *const c_char,
}

impl Default for GenerateContentPart {
    fn default() -> Self {
        Self {
            content_type: 0,
            data_ptr: std::ptr::null(),
            data_len: 0,
            mime_ptr: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/validate.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SemanticValidationResultC {
    pub is_valid: bool,
    pub path: *const c_char,
    pub message: *const c_char,
}

impl Default for SemanticValidationResultC {
    fn default() -> Self {
        Self {
            is_valid: false,
            path: std::ptr::null(),
            message: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/documents.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CSearchResultList {
    pub items: *mut CSearchResult,
    pub count: usize,
    pub _arena: *mut c_void,
}

impl Default for CSearchResultList {
    fn default() -> Self {
        Self {
            items: std::ptr::null_mut(),
            count: 0,
            _arena: std::ptr::null_mut(),
        }
    }
}

/// Source: core/src/capi/documents.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CDocumentRecord {
    pub doc_id: *const c_char,
    pub doc_type: *const c_char,
    pub title: *const c_char,
    pub tags_text: *const c_char,
    pub doc_json: *const c_char,
    pub parent_id: *const c_char,
    pub marker: *const c_char,
    pub group_id: *const c_char,
    pub owner_id: *const c_char,
    pub created_at_ms: i64,
    pub updated_at_ms: i64,
    pub expires_at_ms: i64,
    pub content_hash: u64,
    pub seq_num: u64,
    pub _reserved: [u8; 8],
}

impl Default for CDocumentRecord {
    fn default() -> Self {
        Self {
            doc_id: std::ptr::null(),
            doc_type: std::ptr::null(),
            title: std::ptr::null(),
            tags_text: std::ptr::null(),
            doc_json: std::ptr::null(),
            parent_id: std::ptr::null(),
            marker: std::ptr::null(),
            group_id: std::ptr::null(),
            owner_id: std::ptr::null(),
            created_at_ms: 0,
            updated_at_ms: 0,
            expires_at_ms: 0,
            content_hash: 0,
            seq_num: 0,
            _reserved: [0; 8],
        }
    }
}

/// Source: core/src/capi/documents.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CDeltaChain {
    pub items: *mut CDocumentRecord,
    pub count: usize,
    pub _arena: *mut c_void,
}

impl Default for CDeltaChain {
    fn default() -> Self {
        Self {
            items: std::ptr::null_mut(),
            count: 0,
            _arena: std::ptr::null_mut(),
        }
    }
}

/// Source: core/src/router/capi_bridge.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CRemoteModelListResult {
    pub models: *mut CRemoteModelInfo,
    pub count: usize,
    pub error_code: c_int,
}

impl Default for CRemoteModelListResult {
    fn default() -> Self {
        Self {
            models: std::ptr::null_mut(),
            count: 0,
            error_code: 0,
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DecodeResult {
    pub text: *const u8,
    pub text_len: usize,
    pub error_msg: *const c_char,
}

impl Default for DecodeResult {
    fn default() -> Self {
        Self {
            text: std::ptr::null(),
            text_len: 0,
            error_msg: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PaddedTensorResult {
    pub input_ids: *const u32,
    pub attention_mask: *const u32,
    pub num_sequences: usize,
    pub padded_length: usize,
    pub error_msg: *const c_char,
}

impl Default for PaddedTensorResult {
    fn default() -> Self {
        Self {
            input_ids: std::ptr::null(),
            attention_mask: std::ptr::null(),
            num_sequences: 0,
            padded_length: 0,
            error_msg: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/tokenizer.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VocabResult {
    pub tokens: *const c_char,
    pub lengths: *const u32,
    pub num_entries: usize,
    pub ids: *const u32,
    pub error_msg: *const c_char,
}

impl Default for VocabResult {
    fn default() -> Self {
        Self {
            tokens: std::ptr::null(),
            lengths: std::ptr::null(),
            num_entries: 0,
            ids: std::ptr::null(),
            error_msg: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/file.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaluImageDecodeOptions {
    pub max_input_bytes: usize,
    pub max_dimension: u32,
    pub max_pixels: u64,
    pub max_output_bytes: usize,
    pub prefer_format: c_int,
    pub apply_orientation: u8,
    pub alpha_mode: c_int,
    pub alpha_background_r: u8,
    pub alpha_background_g: u8,
    pub alpha_background_b: u8,
    pub _reserved: [u8; 21],
}

impl Default for TaluImageDecodeOptions {
    fn default() -> Self {
        Self {
            max_input_bytes: 0,
            max_dimension: 0,
            max_pixels: 0,
            max_output_bytes: 0,
            prefer_format: 0,
            apply_orientation: 0,
            alpha_mode: 0,
            alpha_background_r: 0,
            alpha_background_g: 0,
            alpha_background_b: 0,
            _reserved: [0; 21],
        }
    }
}

/// Source: core/src/capi/file.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaluFileInfo {
    pub kind: c_int,
    pub mime_ptr: *const u8,
    pub mime_len: usize,
    pub description_ptr: *const u8,
    pub description_len: usize,
    pub image_format: c_int,
    pub width: u32,
    pub height: u32,
    pub exif_orientation: u8,
    pub _reserved: [u8; 7],
}

impl Default for TaluFileInfo {
    fn default() -> Self {
        Self {
            kind: 0,
            mime_ptr: std::ptr::null(),
            mime_len: 0,
            description_ptr: std::ptr::null(),
            description_len: 0,
            image_format: 0,
            width: 0,
            height: 0,
            exif_orientation: 0,
            _reserved: [0; 7],
        }
    }
}

/// Source: core/src/capi/responses.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CItem {
    pub id: u64,
    pub item_type: u8,
    pub status: u8,
    pub _padding: [u8; 6],
    pub created_at_ms: i64,
    pub input_tokens: u32,
    pub output_tokens: u32,
    pub prefill_ns: u64,
    pub generation_ns: u64,
    pub finish_reason_ptr: *const c_char,
}

impl Default for CItem {
    fn default() -> Self {
        Self {
            id: 0,
            item_type: 0,
            status: 0,
            _padding: [0; 6],
            created_at_ms: 0,
            input_tokens: 0,
            output_tokens: 0,
            prefill_ns: 0,
            generation_ns: 0,
            finish_reason_ptr: std::ptr::null(),
        }
    }
}

/// Source: core/src/capi/db.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CSessionList {
    pub sessions: *mut CSessionRecord,
    pub count: usize,
    pub _allocator: *mut c_void,
    pub _arena: *mut c_void,
}

impl Default for CSessionList {
    fn default() -> Self {
        Self {
            sessions: std::ptr::null_mut(),
            count: 0,
            _allocator: std::ptr::null_mut(),
            _arena: std::ptr::null_mut(),
        }
    }
}

/// Source: core/src/capi/file.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaluImage {
    pub data: *const u8,
    pub len: usize,
    pub width: u32,
    pub height: u32,
    pub stride: u32,
    pub format: c_int,
}

impl Default for TaluImage {
    fn default() -> Self {
        Self {
            data: std::ptr::null(),
            len: 0,
            width: 0,
            height: 0,
            stride: 0,
            format: 0,
        }
    }
}

/// Source: core/src/router/capi_bridge.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CGenerateResult {
    pub text: *const c_char,
    pub token_count: usize,
    pub prompt_tokens: usize,
    pub completion_tokens: usize,
    pub prefill_ns: u64,
    pub generation_ns: u64,
    pub error_code: c_int,
    pub finish_reason: u8,
    pub _padding: [u8; 3],
    pub tool_calls: *const CToolCallRef,
    pub tool_call_count: usize,
}

impl Default for CGenerateResult {
    fn default() -> Self {
        Self {
            text: std::ptr::null(),
            token_count: 0,
            prompt_tokens: 0,
            completion_tokens: 0,
            prefill_ns: 0,
            generation_ns: 0,
            error_code: 0,
            finish_reason: 0,
            _padding: [0; 3],
            tool_calls: std::ptr::null(),
            tool_call_count: 0,
        }
    }
}

/// Source: core/src/capi/db.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CTagList {
    pub tags: *mut CTagRecord,
    pub count: usize,
    pub _arena: *mut c_void,
}

impl Default for CTagList {
    fn default() -> Self {
        Self {
            tags: std::ptr::null_mut(),
            count: 0,
            _arena: std::ptr::null_mut(),
        }
    }
}

/// Source: core/src/capi/file.zig
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaluImageEncodeOptions {
    pub format: c_int,
    pub jpeg_quality: u8,
    pub _reserved: [u8; 27],
}

impl Default for TaluImageEncodeOptions {
    fn default() -> Self {
        Self {
            format: 0,
            jpeg_quality: 0,
            _reserved: [0; 27],
        }
    }
}

// =============================================================================
// Opaque Handles
// =============================================================================

/// Opaque handle for Responses/Conversation.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResponsesHandle {
    _private: [u8; 0],
}

/// Opaque handle for string list.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct StringList {
    _private: [u8; 0],
}

/// Opaque handle for cached model list.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CachedModelList {
    _private: [u8; 0],
}

// =============================================================================
// Callback Types
// =============================================================================

pub type RouterTokenCallback =
    Option<unsafe extern "C" fn(*const c_char, u32, *mut c_void) -> bool>;

/// Unified progress callback - receives structured progress updates from core.
/// This is the new callback type used by all long-running operations.
pub type CProgressCallback = Option<unsafe extern "C" fn(*const ProgressUpdate, *mut c_void)>;

/// Legacy progress callback (deprecated - use CProgressCallback).
pub type ProgressCallback = Option<unsafe extern "C" fn(u64, u64, *mut c_void)>;

/// Legacy file start callback (deprecated - use CProgressCallback).
pub type FileStartCallback = Option<unsafe extern "C" fn(*const c_char, *mut c_void)>;

pub type StorageCallback = Option<unsafe extern "C" fn(*const CStorageEvent, *mut c_void) -> i32>;

// =============================================================================
// Type Aliases (Backwards Compatibility)
// =============================================================================
//
// These aliases allow wrapper code to use cleaner names without the C prefix.
// New code should prefer the C-prefixed names to match the Zig C API.

pub type MessageRole = CMessageRole;
pub type ItemType = CItemType;
pub type StorageEventType = CStorageEventType;
pub type PoolingStrategy = CPoolingStrategy;

/// Alias for CContentPart (legacy name used in some wrapper code)
pub type CResponsesContentPart = CContentPart;

// =============================================================================
// Semantic Enums (Not in Zig C API, but documented in field comments)
// =============================================================================
//
// These enums represent values stored in u8 fields with documented meanings.
// They are manually defined here for type safety in Rust wrapper code.

/// Content type discriminator.
/// Matches values documented in CContentPart.content_type.
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum ContentType {
    InputText = 0,
    InputImage = 1,
    InputAudio = 2,
    InputFile = 3,
    InputVideo = 4,
    OutputText = 5,
    Refusal = 6,
    Text = 7,
    ReasoningText = 8,
    SummaryText = 9,
    Unknown = 255,
}

impl From<u8> for ContentType {
    fn from(value: u8) -> Self {
        match value {
            0 => ContentType::InputText,
            1 => ContentType::InputImage,
            2 => ContentType::InputAudio,
            3 => ContentType::InputFile,
            4 => ContentType::InputVideo,
            5 => ContentType::OutputText,
            6 => ContentType::Refusal,
            7 => ContentType::Text,
            8 => ContentType::ReasoningText,
            9 => ContentType::SummaryText,
            _ => ContentType::Unknown,
        }
    }
}

/// Image detail level.
/// Matches values documented in CContentPart.image_detail.
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Default)]
pub enum ImageDetail {
    #[default]
    Auto = 0,
    Low = 1,
    High = 2,
}

impl From<u8> for ImageDetail {
    fn from(value: u8) -> Self {
        match value {
            0 => ImageDetail::Auto,
            1 => ImageDetail::Low,
            2 => ImageDetail::High,
            _ => ImageDetail::Auto,
        }
    }
}

/// Item status.
/// Matches values documented in CItem.status and CStorageRecord.status.
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Default)]
pub enum ItemStatus {
    #[default]
    InProgress = 0,
    Waiting = 1,
    Completed = 2,
    Incomplete = 3,
    Failed = 4,
}

impl From<u8> for ItemStatus {
    fn from(value: u8) -> Self {
        match value {
            0 => ItemStatus::InProgress,
            1 => ItemStatus::Waiting,
            2 => ItemStatus::Completed,
            3 => ItemStatus::Incomplete,
            4 => ItemStatus::Failed,
            _ => ItemStatus::InProgress,
        }
    }
}

// =============================================================================
// C API Functions
// =============================================================================

extern "C" {
    // core/src/capi/memory.zig
    pub fn talu_alloc_string(len: usize) -> *const u8;
    // core/src/capi/session.zig
    pub fn talu_apply_chat_template(
        model_path: *const c_char,
        messages_json: *const c_char,
        add_generation_prompt: c_int,
        out_prompt: *mut c_void,
    ) -> c_int;
    // core/src/capi/session.zig
    pub fn talu_apply_chat_template_string(
        template_ptr: *const u8,
        template_len: usize,
        messages_json: *const c_char,
        add_generation_prompt: c_int,
        bos_token: *const c_char,
        eos_token: *const c_char,
        out_prompt: *mut c_void,
    ) -> c_int;
    // core/src/capi/architecture.zig
    pub fn talu_arch_count() -> usize;
    // core/src/capi/architecture.zig
    pub fn talu_arch_deinit();
    // core/src/capi/architecture.zig
    pub fn talu_arch_detect(model_type_cstr: *const c_char, out_name: *mut c_void) -> c_int;
    // core/src/capi/architecture.zig
    pub fn talu_arch_exists(name_cstr: *const c_char) -> bool;
    // core/src/capi/architecture.zig
    pub fn talu_arch_free_string(ptr: *const c_char);
    // core/src/capi/architecture.zig
    pub fn talu_arch_init();
    // core/src/capi/architecture.zig
    pub fn talu_arch_list(out_json: *mut c_void) -> c_int;
    // core/src/capi/architecture.zig
    pub fn talu_arch_register(json_cstr: *const c_char) -> c_int;
    // core/src/capi/router.zig
    pub fn talu_backend_create_from_canonical(
        canon: *mut c_void,
        options: BackendCreateOptions,
        out_backend: *mut c_void,
    ) -> c_int;
    // core/src/capi/router.zig
    pub fn talu_backend_free(backend: *mut c_void);
    // core/src/capi/router.zig
    pub fn talu_backend_get_capabilities(
        backend_type_raw: c_int,
        backend_config: BackendUnion,
        out_caps: *mut TaluCapabilities,
    ) -> c_int;
    // core/src/capi/router.zig
    pub fn talu_backend_list_models(backend: *mut c_void) -> CRemoteModelListResult;
    // core/src/capi/router.zig
    pub fn talu_backend_list_models_free(result: *mut c_void);
    // core/src/capi/tokenizer.zig
    pub fn talu_batch_encode_result_free(
        ids: *const u32,
        offsets: *const usize,
        total_tokens: usize,
        num_sequences: usize,
    );
    // core/src/capi/dlpack.zig
    pub fn talu_batch_mask_to_dlpack(
        ids: *const u32,
        offsets: *const usize,
        num_sequences: usize,
        max_length: usize,
        padding_side: u8,
    ) -> *mut c_void;
    // core/src/capi/dlpack.zig
    pub fn talu_batch_to_dlpack(
        ids: *const u32,
        offsets: *const usize,
        num_sequences: usize,
        pad_id: u32,
        max_length: usize,
        padding_side: u8,
    ) -> *mut c_void;
    // core/src/capi/tokenizer.zig
    pub fn talu_batch_to_padded_tensor(
        ids: *const u32,
        offsets: *const usize,
        num_sequences: usize,
        options: PaddedTensorOptions,
    ) -> PaddedTensorResult;
    // core/src/capi/blobs.zig
    pub fn talu_blobs_exists(
        db_path: *const c_char,
        blob_ref: *const c_char,
        out_exists: *mut c_void,
    ) -> c_int;
    // core/src/capi/blobs.zig
    pub fn talu_blobs_free_string_list(list: *mut CStringList);
    // core/src/capi/blobs.zig
    pub fn talu_blobs_gc(
        db_path: *const c_char,
        min_blob_age_seconds: u64,
        out_stats: *mut c_void,
    ) -> c_int;
    // core/src/capi/blobs.zig
    pub fn talu_blobs_list(db_path: *const c_char, limit: usize, out_refs: *mut c_void) -> c_int;
    // core/src/capi/blobs.zig
    pub fn talu_blobs_open_stream(
        db_path: *const c_char,
        blob_ref: *const c_char,
        out_stream: *mut c_void,
    ) -> c_int;
    // core/src/capi/blobs.zig
    pub fn talu_blobs_open_write_stream(db_path: *const c_char, out_stream: *mut c_void) -> c_int;
    // core/src/capi/blobs.zig
    pub fn talu_blobs_put(
        db_path: *const c_char,
        bytes: *const u8,
        bytes_len: usize,
        out_blob_ref: *const u8,
        out_blob_ref_capacity: usize,
    ) -> c_int;
    // core/src/capi/blobs.zig
    pub fn talu_blobs_stream_close(stream_handle: *mut c_void);
    // core/src/capi/blobs.zig
    pub fn talu_blobs_stream_read(
        stream_handle: *mut c_void,
        out_buffer: *const u8,
        out_buffer_len: usize,
        out_read_len: *mut c_void,
    ) -> c_int;
    // core/src/capi/blobs.zig
    pub fn talu_blobs_stream_seek(stream_handle: *mut c_void, offset_bytes: u64) -> c_int;
    // core/src/capi/blobs.zig
    pub fn talu_blobs_stream_total_size(
        stream_handle: *mut c_void,
        out_total_size: *mut c_void,
    ) -> c_int;
    // core/src/capi/blobs.zig
    pub fn talu_blobs_write_stream_close(stream_handle: *mut c_void);
    // core/src/capi/blobs.zig
    pub fn talu_blobs_write_stream_finish(
        stream_handle: *mut c_void,
        out_blob_ref: *const u8,
        out_blob_ref_capacity: usize,
    ) -> c_int;
    // core/src/capi/blobs.zig
    pub fn talu_blobs_write_stream_write(
        stream_handle: *mut c_void,
        bytes: *const u8,
        bytes_len: usize,
    ) -> c_int;
    // core/src/capi/buffer.zig
    pub fn talu_buffer_create_from_copy(tokens: *const u32, num_tokens: usize) -> *mut c_void;
    // core/src/capi/buffer.zig
    pub fn talu_buffer_create_from_owned(tokens: *const u32, num_tokens: usize) -> *mut c_void;
    // core/src/capi/buffer.zig
    pub fn talu_buffer_create_uninitialized(capacity: usize) -> *mut c_void;
    // core/src/capi/buffer.zig
    pub fn talu_buffer_get_capacity(handle: *mut c_void) -> usize;
    // core/src/capi/buffer.zig
    pub fn talu_buffer_get_data_ptr(handle: *mut c_void) -> *const u32;
    // core/src/capi/buffer.zig
    pub fn talu_buffer_get_refcount(handle: *mut c_void) -> usize;
    // core/src/capi/buffer.zig
    pub fn talu_buffer_release(handle: *mut c_void) -> u8;
    // core/src/capi/buffer.zig
    pub fn talu_buffer_retain(handle: *mut c_void);
    // core/src/capi/dlpack.zig
    pub fn talu_buffer_to_dlpack(
        buffer_handle: *mut c_void,
        offset_elems: usize,
        len: usize,
    ) -> *mut c_void;
    // core/src/capi/responses.zig
    pub fn talu_chat_clear(handle: *mut c_void);
    // core/src/capi/responses.zig
    pub fn talu_chat_count_tokens(
        chat_handle: *mut c_void,
        model: *const c_char,
        additional_message: *const u8,
        additional_message_len: usize,
    ) -> i64;
    // core/src/capi/responses.zig
    pub fn talu_chat_create(options: *mut ChatCreateOptions) -> *mut c_void;
    // core/src/capi/responses.zig
    pub fn talu_chat_create_with_session(
        session_id: *const c_char,
        options: *mut ChatCreateOptions,
    ) -> *mut c_void;
    // core/src/capi/responses.zig
    pub fn talu_chat_create_with_system(
        system: *const c_char,
        options: *mut ChatCreateOptions,
    ) -> *mut c_void;
    // core/src/capi/responses.zig
    pub fn talu_chat_create_with_system_and_session(
        system: *const c_char,
        session_id: *const c_char,
        options: *mut ChatCreateOptions,
    ) -> *mut c_void;
    // core/src/capi/responses.zig
    pub fn talu_chat_free(handle: *mut c_void);
    // core/src/capi/responses.zig
    pub fn talu_chat_get_conversation(handle: *mut c_void) -> *mut ResponsesHandle;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_max_tokens(handle: *mut c_void) -> usize;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_messages(handle: *mut c_void) -> *mut c_void;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_min_p(handle: *mut c_void) -> f32;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_prompt_id(handle: *mut c_void) -> *const c_char;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_repetition_penalty(handle: *mut c_void) -> f32;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_session_id(handle: *mut c_void) -> *const c_char;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_system(handle: *mut c_void) -> *const c_char;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_temperature(handle: *mut c_void) -> f32;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_tool_choice(handle: *mut c_void) -> *const c_char;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_tools(handle: *mut c_void) -> *const c_char;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_top_k(handle: *mut c_void) -> usize;
    // core/src/capi/responses.zig
    pub fn talu_chat_get_top_p(handle: *mut c_void) -> f32;
    // core/src/capi/db.zig
    pub fn talu_chat_inherit_tags(chat_handle: *mut c_void, db_path: *const c_char) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_chat_len(handle: *mut c_void) -> usize;
    // core/src/capi/responses.zig
    pub fn talu_chat_max_context_length(model: *const c_char) -> u64;
    // core/src/capi/db.zig
    pub fn talu_chat_notify_session_update(
        chat_handle: *mut c_void,
        model: *const c_char,
        title: *const c_char,
        system_prompt: *const c_char,
        config_json: *const c_char,
        marker: *const c_char,
        parent_session_id: *const c_char,
        group_id: *const c_char,
        metadata_json: *const c_char,
        source_doc_id: *const c_char,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_chat_reset(handle: *mut c_void);
    // core/src/capi/db.zig
    pub fn talu_chat_set_durability(chat_handle: *mut c_void, mode: u8) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_chat_set_max_segment_size(chat_handle: *mut c_void, max_bytes: u64) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_chat_set_max_tokens(handle: *mut c_void, value: usize);
    // core/src/capi/responses.zig
    pub fn talu_chat_set_messages(handle: *mut c_void, json: *const c_char) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_chat_set_min_p(handle: *mut c_void, value: f32);
    // core/src/capi/policy.zig
    pub fn talu_chat_set_policy(chat_handle: *mut c_void, policy_handle: *mut c_void) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_chat_set_prompt_id(handle: *mut c_void, prompt_id: *const c_char) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_chat_set_repetition_penalty(handle: *mut c_void, value: f32);
    // core/src/capi/db.zig
    pub fn talu_chat_set_storage_db(
        chat_handle: *mut c_void,
        db_path: *const c_char,
        session_id: *const c_char,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_chat_set_system(handle: *mut c_void, system: *const c_char) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_chat_set_temperature(handle: *mut c_void, value: f32);
    // core/src/capi/responses.zig
    pub fn talu_chat_set_tool_choice(
        handle: *mut c_void,
        json: *const c_char,
        json_len: usize,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_chat_set_tools(handle: *mut c_void, json: *const c_char, json_len: usize) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_chat_set_top_k(handle: *mut c_void, value: usize);
    // core/src/capi/responses.zig
    pub fn talu_chat_set_top_p(handle: *mut c_void, value: f32);
    // core/src/capi/responses.zig
    pub fn talu_chat_set_ttl_ts(handle: *mut c_void, ttl_ts: i64) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_chat_simulate_crash(chat_handle: *mut c_void) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_chat_to_json(handle: *mut c_void) -> *const c_char;
    // core/src/capi/responses.zig
    pub fn talu_chat_validate(handle: *mut c_void) -> c_int;
    // core/src/capi/error.zig
    pub fn talu_clear_error();
    // core/src/capi/validate.zig
    pub fn talu_clear_response_format(chat_handle: *mut c_void);
    // core/src/capi/router.zig
    pub fn talu_config_canonicalize(in_spec: *mut TaluModelSpec, out_handle: *mut c_void) -> c_int;
    // core/src/capi/router.zig
    pub fn talu_config_free(handle: *mut c_void);
    // core/src/capi/router.zig
    pub fn talu_config_get_view(handle: *mut c_void, out_spec: *mut TaluModelSpec) -> c_int;
    // core/src/capi/router.zig
    pub fn talu_config_validate(spec: *mut TaluModelSpec) -> c_int;
    // core/src/capi/converter.zig
    pub fn talu_convert(
        model_path: *const c_char,
        output_dir: *const c_char,
        options: *const ConvertOptions,
    ) -> ConvertResult;
    // core/src/capi/converter.zig
    pub fn talu_convert_free_string(string_ptr: *const c_char);
    // core/src/capi/converter.zig
    pub fn talu_convert_parse_scheme(name: *const c_char) -> c_int;
    // core/src/capi/converter.zig
    pub fn talu_convert_schemes(out_schemes: *mut c_void) -> c_int;
    // core/src/capi/tokenizer.zig
    pub fn talu_decode_result_free(text: *const u8, text_len: usize);
    // core/src/capi/converter.zig
    pub fn talu_describe(model_path: *const c_char) -> ModelInfo;
    // core/src/capi/tensor.zig
    pub fn talu_dlpack_capsule_name() -> *const c_char;
    // core/src/capi/tensor.zig
    pub fn talu_dlpack_used_capsule_name() -> *const c_char;
    // core/src/capi/documents.zig
    pub fn talu_documents_add_tag(
        db_path: *const c_char,
        doc_id: *const c_char,
        tag_id: *const c_char,
        group_id: *const c_char,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_count_expired(db_path: *const c_char, out_count: *mut c_void) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_create(
        db_path: *const c_char,
        doc_id: *const c_char,
        doc_type: *const c_char,
        title: *const c_char,
        doc_json: *const c_char,
        tags_text: *const c_char,
        parent_id: *const c_char,
        marker: *const c_char,
        group_id: *const c_char,
        owner_id: *const c_char,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_create_delta(
        db_path: *const c_char,
        base_doc_id: *const c_char,
        new_doc_id: *const c_char,
        delta_json: *const c_char,
        title: *const c_char,
        tags_text: *const c_char,
        marker: *const c_char,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_delete(db_path: *const c_char, doc_id: *const c_char) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_free_changes(list: *mut CChangeList);
    // core/src/capi/documents.zig
    pub fn talu_documents_free_delta_chain(chain: *mut CDeltaChain);
    // core/src/capi/documents.zig
    pub fn talu_documents_free_json(ptr: *const u8, len: usize);
    // core/src/capi/documents.zig
    pub fn talu_documents_free_list(list: *mut CDocumentList);
    // core/src/capi/documents.zig
    pub fn talu_documents_free_search_results(list: *mut CSearchResultList);
    // core/src/capi/documents.zig
    pub fn talu_documents_free_string_list(list: *mut CStringList);
    // core/src/capi/documents.zig
    pub fn talu_documents_get(
        db_path: *const c_char,
        doc_id: *const c_char,
        out_doc: *mut CDocumentRecord,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_get_base_id(
        db_path: *const c_char,
        doc_id: *const c_char,
        out_base_id: *const u8,
        out_base_id_len: usize,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_get_blob_ref(
        db_path: *const c_char,
        doc_id: *const c_char,
        out_blob_ref: *const u8,
        out_blob_ref_capacity: usize,
        out_has_external_ref: *mut c_void,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_get_by_tag(
        db_path: *const c_char,
        tag_id: *const c_char,
        out_doc_ids: *mut c_void,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_get_changes(
        db_path: *const c_char,
        since_seq: u64,
        group_id: *const c_char,
        limit: u32,
        out_list: *mut c_void,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_get_compaction_stats(
        db_path: *const c_char,
        out_stats: *mut CCompactionStats,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_get_delta_chain(
        db_path: *const c_char,
        doc_id: *const c_char,
        out_chain: *mut c_void,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_get_garbage_candidates(
        db_path: *const c_char,
        out_ids: *mut c_void,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_get_tags(
        db_path: *const c_char,
        doc_id: *const c_char,
        out_tag_ids: *mut c_void,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_is_delta(
        db_path: *const c_char,
        doc_id: *const c_char,
        out_is_delta: *mut c_void,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_list(
        db_path: *const c_char,
        doc_type: *const c_char,
        group_id: *const c_char,
        owner_id: *const c_char,
        marker: *const c_char,
        limit: u32,
        out_list: *mut c_void,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_purge_expired(db_path: *const c_char, out_count: *mut c_void) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_remove_tag(
        db_path: *const c_char,
        doc_id: *const c_char,
        tag_id: *const c_char,
        group_id: *const c_char,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_search(
        db_path: *const c_char,
        query: *const c_char,
        doc_type: *const c_char,
        limit: u32,
        out_list: *mut c_void,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_search_batch(
        db_path: *const c_char,
        queries_json: *const u8,
        queries_len: usize,
        out_results_json: *mut c_void,
        out_results_len: *mut c_void,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_set_ttl(
        db_path: *const c_char,
        doc_id: *const c_char,
        ttl_seconds: u64,
    ) -> c_int;
    // core/src/capi/documents.zig
    pub fn talu_documents_update(
        db_path: *const c_char,
        doc_id: *const c_char,
        title: *const c_char,
        doc_json: *const c_char,
        tags_text: *const c_char,
        marker: *const c_char,
    ) -> c_int;
    // core/src/capi/tokenizer.zig
    pub fn talu_encode_result_free(result: EncodeResult);
    // core/src/capi/error.zig
    pub fn talu_error_buf_size() -> usize;
    // core/src/capi/converter.zig
    pub fn talu_execution_plan(info: *mut ModelInfo) -> ExecutionPlanInfo;
    // core/src/capi/file.zig
    pub fn talu_file_bytes_free(bytes: *const u8, len: usize);
    // core/src/capi/file.zig
    pub fn talu_file_info_free(info: *mut TaluFileInfo);
    // core/src/capi/file.zig
    pub fn talu_file_inspect(
        bytes: *const u8,
        bytes_len: usize,
        out_info: *mut TaluFileInfo,
    ) -> c_int;
    // core/src/capi/file.zig
    pub fn talu_file_transform(
        bytes: *const u8,
        bytes_len: usize,
        opts: *const TaluFileTransformOptions,
        out_bytes: *mut c_void,
        out_len: *mut c_void,
        out_info: *mut TaluFileInfo,
    ) -> c_int;
    // core/src/capi/template.zig
    pub fn talu_free_spans(spans: *mut c_void, count: u32);
    // core/src/capi/memory.zig
    pub fn talu_free_string(ptr: *const u8, len: usize);
    // core/src/capi/template.zig
    pub fn talu_get_chat_template_source(
        model_path: *const c_char,
        out_source: *mut c_void,
    ) -> c_int;
    // core/src/capi/session.zig
    pub fn talu_get_eos_tokens(model_dir: *const c_char) -> EosTokenResult;
    // core/src/capi/session.zig
    pub fn talu_get_generation_config(
        model_dir: *const c_char,
        out_config: *mut GenerationConfigInfo,
    ) -> c_int;
    // core/src/capi/log.zig
    pub fn talu_get_log_format() -> c_int;
    // core/src/capi/log.zig
    pub fn talu_get_log_level() -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_grammar_compile(schema_json: *const c_char) -> *mut c_void;
    // core/src/capi/validate.zig
    pub fn talu_grammar_free(handle: *mut c_void);
    // core/src/capi/tensor.zig
    pub fn talu_hello() -> *const c_char;
    // core/src/capi/file.zig
    pub fn talu_image_convert(
        src: *const TaluImage,
        opts: *const TaluImageConvertOptions,
        out_image: *mut TaluImage,
    ) -> c_int;
    // core/src/capi/file.zig
    pub fn talu_image_decode(
        bytes: *const u8,
        bytes_len: usize,
        opts: *const TaluImageDecodeOptions,
        out_image: *mut TaluImage,
    ) -> c_int;
    // core/src/capi/file.zig
    pub fn talu_image_encode(
        src: *const TaluImage,
        opts: *const TaluImageEncodeOptions,
        out_bytes: *mut c_void,
        out_len: *mut c_void,
    ) -> c_int;
    // core/src/capi/file.zig
    pub fn talu_image_encode_free(bytes: *const u8, len: usize);
    // core/src/capi/file.zig
    pub fn talu_image_free(img: *mut TaluImage);
    // core/src/capi/file.zig
    pub fn talu_image_to_model_input(
        bytes: *const u8,
        bytes_len: usize,
        spec: *const TaluModelInputSpec,
        out_buffer: *mut TaluModelBuffer,
    ) -> c_int;
    // core/src/capi/error.zig
    pub fn talu_last_error() -> *const c_char;
    // core/src/capi/error.zig
    pub fn talu_last_error_code() -> c_int;
    // core/src/capi/file.zig
    pub fn talu_model_buffer_free(buf: *mut TaluModelBuffer);
    // core/src/capi/converter.zig
    pub fn talu_model_info_free(info: *mut ModelInfo);
    // core/src/capi/tokenizer.zig
    pub fn talu_padded_tensor_result_free(
        input_ids: *const u32,
        attention_mask: *const u32,
        num_sequences: usize,
        padded_length: usize,
    );
    // core/src/capi/plugins.zig
    pub fn talu_plugins_list_count(list: *const CPluginList) -> u32;
    // core/src/capi/plugins.zig
    pub fn talu_plugins_list_free(list: *mut CPluginList);
    // core/src/capi/plugins.zig
    pub fn talu_plugins_list_get(list: *const CPluginList, index: u32) -> *const CPluginInfo;
    // core/src/capi/plugins.zig
    pub fn talu_plugins_scan(plugins_dir: *const c_char, out_list: *mut c_void) -> c_int;
    // core/src/capi/policy.zig
    pub fn talu_policy_create(
        json_ptr: *const u8,
        json_len: usize,
        out_policy: *mut c_void,
    ) -> c_int;
    // core/src/capi/policy.zig
    pub fn talu_policy_evaluate(
        handle: *mut c_void,
        action_ptr: *const u8,
        action_len: usize,
    ) -> u8;
    // core/src/capi/policy.zig
    pub fn talu_policy_free(handle: *mut c_void);
    // core/src/capi/policy.zig
    pub fn talu_policy_get_mode(handle: *mut c_void) -> u8;
    // core/src/capi/provider.zig
    pub fn talu_provider_count() -> usize;
    // core/src/capi/provider.zig
    pub fn talu_provider_get(index: usize, out: *mut CProviderInfo) -> c_int;
    // core/src/capi/provider.zig
    pub fn talu_provider_get_by_name(name: *const c_char, out: *mut CProviderInfo) -> c_int;
    // core/src/capi/provider.zig
    pub fn talu_provider_has_prefix(model_id: *const c_char) -> c_int;
    // core/src/capi/provider.zig
    pub fn talu_provider_parse(
        model_id: *const c_char,
        provider_out: *mut CProviderInfo,
        model_id_start: *mut c_void,
        model_id_len: *mut c_void,
    ) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_cache_dir_exists(model_id: *const c_char) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_delete(model_id: *const c_char) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_exists(model_id: *const c_char, token: *const c_char) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_fetch(
        model_id: *const c_char,
        options: *mut DownloadOptions,
        out: *mut c_void,
    ) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_fetch_file(
        model_id: *const c_char,
        filename: *const c_char,
        options: *mut DownloadOptions,
        out: *mut c_void,
    ) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_get_cache_dir(model_id: *const c_char, out: *mut c_void) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_get_cached_path(
        model_id: *const c_char,
        require_weights: bool,
        out: *mut c_void,
    ) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_get_hf_home(out: *mut c_void) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_get_talu_home(out: *mut c_void) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_is_cached(model_id: *const c_char) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_is_model_id(path: *const c_char) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_list(
        model_path: *const c_char,
        token: *const c_char,
        out: *mut *mut c_void,
    ) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_list_count(list: *mut CachedModelList) -> usize;
    // core/src/capi/repository.zig
    pub fn talu_repo_list_free(list: *mut CachedModelList);
    // core/src/capi/repository.zig
    pub fn talu_repo_list_get_id(list: *mut CachedModelList, idx: usize, out: *mut c_void)
        -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_list_get_path(
        list: *mut CachedModelList,
        idx: usize,
        out: *mut c_void,
    ) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_list_get_source(list: *mut CachedModelList, idx: usize) -> u8;
    // core/src/capi/repository.zig
    pub fn talu_repo_list_models(require_weights: bool, out: *mut *mut c_void) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_mtime(model_id: *const c_char) -> i64;
    // core/src/capi/repository.zig
    pub fn talu_repo_resolve_path(
        uri: *const c_char,
        offline: bool,
        token: *const c_char,
        endpoint_url: *const c_char,
        require_weights: bool,
        out_path: *mut c_void,
    ) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_search(
        query: *const c_char,
        limit: usize,
        token: *const c_char,
        endpoint_url: *const c_char,
        out: *mut *mut c_void,
    ) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_search_result_count(list: *mut c_void) -> usize;
    // core/src/capi/repository.zig
    pub fn talu_repo_search_result_free(list: *mut c_void);
    // core/src/capi/repository.zig
    pub fn talu_repo_search_result_get_downloads(list: *mut c_void, idx: usize) -> i64;
    // core/src/capi/repository.zig
    pub fn talu_repo_search_result_get_id(list: *mut c_void, idx: usize, out: *mut c_void)
        -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_search_result_get_last_modified(
        list: *mut c_void,
        idx: usize,
        out: *mut c_void,
    ) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_search_result_get_likes(list: *mut c_void, idx: usize) -> i64;
    // core/src/capi/repository.zig
    pub fn talu_repo_search_result_get_params(list: *mut c_void, idx: usize) -> i64;
    // core/src/capi/repository.zig
    pub fn talu_repo_search_result_get_pipeline_tag(
        list: *mut c_void,
        idx: usize,
        out: *mut c_void,
    ) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_search_rich(
        query: *const c_char,
        limit: usize,
        token: *const c_char,
        endpoint_url: *const c_char,
        filter: *const c_char,
        sort: u8,
        direction: u8,
        library: *const c_char,
        out: *mut *mut c_void,
    ) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_size(model_id: *const c_char) -> u64;
    // core/src/capi/repository.zig
    pub fn talu_repo_string_list_count(list: *mut StringList) -> usize;
    // core/src/capi/repository.zig
    pub fn talu_repo_string_list_free(list: *mut StringList);
    // core/src/capi/repository.zig
    pub fn talu_repo_string_list_get(list: *mut StringList, idx: usize, out: *mut c_void) -> c_int;
    // core/src/capi/repository.zig
    pub fn talu_repo_total_size() -> u64;
    // core/src/capi/session.zig
    pub fn talu_resolve_model_path(model_path: *const c_char, out_path: *mut c_void) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_append_function_call(
        handle: *mut ResponsesHandle,
        call_id: *const c_char,
        name: *const c_char,
        arguments_ptr: *const u8,
        arguments_len: usize,
    ) -> i64;
    // core/src/capi/responses.zig
    pub fn talu_responses_append_function_call_output(
        handle: *mut ResponsesHandle,
        call_id: *const c_char,
        output_ptr: *const u8,
        output_len: usize,
    ) -> i64;
    // core/src/capi/responses.zig
    pub fn talu_responses_append_message(
        handle: *mut ResponsesHandle,
        role: u8,
        content_ptr: *const u8,
        content_len: usize,
    ) -> i64;
    // core/src/capi/responses.zig
    pub fn talu_responses_append_message_hidden(
        handle: *mut ResponsesHandle,
        role: u8,
        content_ptr: *const u8,
        content_len: usize,
        hidden: bool,
    ) -> i64;
    // core/src/capi/responses.zig
    pub fn talu_responses_append_text_content(
        handle: *mut ResponsesHandle,
        item_index: usize,
        content_ptr: *const u8,
        content_len: usize,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_begin_fork(handle: *mut ResponsesHandle) -> u64;
    // core/src/capi/responses.zig
    pub fn talu_responses_clear(handle: *mut ResponsesHandle);
    // core/src/capi/responses.zig
    pub fn talu_responses_clear_keeping_system(handle: *mut ResponsesHandle);
    // core/src/capi/responses.zig
    pub fn talu_responses_clone(
        dest_handle: *mut ResponsesHandle,
        source_handle: *mut ResponsesHandle,
        batch_size: usize,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_clone_prefix(
        dest_handle: *mut ResponsesHandle,
        source_handle: *mut ResponsesHandle,
        last_index: usize,
        batch_size: usize,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_create() -> *mut ResponsesHandle;
    // core/src/capi/responses.zig
    pub fn talu_responses_create_with_session(session_id: *const c_char) -> *mut ResponsesHandle;
    // core/src/capi/responses.zig
    pub fn talu_responses_end_fork(handle: *mut ResponsesHandle, fork_id: u64) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_free(handle: *mut ResponsesHandle);
    // core/src/capi/responses.zig
    pub fn talu_responses_get_item(
        handle: *mut ResponsesHandle,
        index: usize,
        out: *mut CItem,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_insert_message(
        handle: *mut ResponsesHandle,
        index: usize,
        role: u8,
        content_ptr: *const u8,
        content_len: usize,
    ) -> i64;
    // core/src/capi/responses.zig
    pub fn talu_responses_insert_message_hidden(
        handle: *mut ResponsesHandle,
        index: usize,
        role: u8,
        content_ptr: *const u8,
        content_len: usize,
        hidden: bool,
    ) -> i64;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_as_function_call(
        handle: *mut ResponsesHandle,
        index: usize,
        out: *mut CFunctionCallItem,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_as_function_call_output(
        handle: *mut ResponsesHandle,
        index: usize,
        out: *mut CFunctionCallOutputItem,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_as_item_reference(
        handle: *mut ResponsesHandle,
        index: usize,
        out: *mut CItemReferenceItem,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_as_message(
        handle: *mut ResponsesHandle,
        index: usize,
        out: *mut CMessageItem,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_as_reasoning(
        handle: *mut ResponsesHandle,
        index: usize,
        out: *mut CReasoningItem,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_count(handle: *mut ResponsesHandle) -> usize;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_fco_get_part(
        handle: *mut ResponsesHandle,
        item_index: usize,
        part_index: usize,
        out: *mut CContentPart,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_get_generation_json(
        handle: *mut ResponsesHandle,
        index: usize,
        out_ptr: *mut c_void,
        out_len: *mut c_void,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_message_content_count(
        handle: *mut ResponsesHandle,
        index: usize,
    ) -> usize;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_message_get_content(
        handle: *mut ResponsesHandle,
        item_index: usize,
        part_index: usize,
        out: *mut CContentPart,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_reasoning_content_count(
        handle: *mut ResponsesHandle,
        index: usize,
    ) -> usize;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_reasoning_get_content(
        handle: *mut ResponsesHandle,
        item_index: usize,
        part_index: usize,
        out: *mut CContentPart,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_reasoning_get_summary(
        handle: *mut ResponsesHandle,
        item_index: usize,
        part_index: usize,
        out: *mut CContentPart,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_reasoning_summary_count(
        handle: *mut ResponsesHandle,
        index: usize,
    ) -> usize;
    // core/src/capi/responses.zig
    pub fn talu_responses_item_type(handle: *mut ResponsesHandle, index: usize) -> u8;
    // core/src/capi/responses.zig
    pub fn talu_responses_load_completions_json(
        handle: *mut ResponsesHandle,
        json: *const c_char,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_load_responses_json(
        handle: *mut ResponsesHandle,
        json: *const c_char,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_load_storage_records(
        handle: *mut ResponsesHandle,
        records_ptr: *const CStorageRecord,
        records_len: usize,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_pop(handle: *mut ResponsesHandle) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_remove(handle: *mut ResponsesHandle, index: usize) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_set_item_parent(
        handle: *mut ResponsesHandle,
        item_index: usize,
        parent_item_id: u64,
        has_parent: bool,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_set_item_status(
        handle: *mut ResponsesHandle,
        item_index: usize,
        status: u8,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_set_item_validation_flags(
        handle: *mut ResponsesHandle,
        item_index: usize,
        json_valid: bool,
        schema_valid: bool,
        repaired: bool,
    ) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_to_completions_json(handle: *mut ResponsesHandle) -> *const c_char;
    // core/src/capi/responses.zig
    pub fn talu_responses_to_responses_json(
        handle: *mut ResponsesHandle,
        direction: u8,
    ) -> *const c_char;
    // core/src/capi/responses.zig
    pub fn talu_responses_truncate_after(handle: *mut ResponsesHandle, last_index: usize) -> c_int;
    // core/src/capi/responses.zig
    pub fn talu_responses_validate(handle: *mut ResponsesHandle) -> c_int;
    // core/src/capi/router.zig
    pub fn talu_router_close_all();
    // core/src/capi/router.zig
    pub fn talu_router_create_iterator(
        chat_handle: *mut c_void,
        parts: *const GenerateContentPart,
        num_parts: usize,
        backend: *mut c_void,
        config: *const CGenerateConfig,
    ) -> *mut c_void;
    // core/src/capi/router.zig
    pub fn talu_router_embed(
        model: *const c_char,
        text: *const c_char,
        pooling: CPoolingStrategy,
        normalize: bool,
        out_embedding: *mut c_void,
        out_dim: *mut c_void,
    ) -> c_int;
    // core/src/capi/router.zig
    pub fn talu_router_embedding_dim(model: *const c_char) -> usize;
    // core/src/capi/router.zig
    pub fn talu_router_embedding_free(embedding: *const f32, dim: usize);
    // core/src/capi/router.zig
    pub fn talu_router_generate_with_backend(
        chat_handle: *mut c_void,
        parts: *const GenerateContentPart,
        num_parts: usize,
        backend: *mut c_void,
        config: *const CGenerateConfig,
    ) -> CGenerateResult;
    // core/src/capi/router.zig
    pub fn talu_router_iterator_cancel(iterator: *mut c_void);
    // core/src/capi/router.zig
    pub fn talu_router_iterator_completion_tokens(iterator: *mut c_void) -> usize;
    // core/src/capi/router.zig
    pub fn talu_router_iterator_content_type(iterator: *mut c_void) -> u8;
    // core/src/capi/router.zig
    pub fn talu_router_iterator_error_code(iterator: *mut c_void) -> c_int;
    // core/src/capi/router.zig
    pub fn talu_router_iterator_error_msg(iterator: *mut c_void) -> *const c_char;
    // core/src/capi/router.zig
    pub fn talu_router_iterator_finish_reason(iterator: *mut c_void) -> u8;
    // core/src/capi/router.zig
    pub fn talu_router_iterator_free(iterator: *mut c_void);
    // core/src/capi/router.zig
    pub fn talu_router_iterator_generation_ns(iterator: *mut c_void) -> u64;
    // core/src/capi/router.zig
    pub fn talu_router_iterator_has_error(iterator: *mut c_void) -> bool;
    // core/src/capi/router.zig
    pub fn talu_router_iterator_item_type(iterator: *mut c_void) -> u8;
    // core/src/capi/router.zig
    pub fn talu_router_iterator_next(iterator: *mut c_void) -> *const c_char;
    // core/src/capi/router.zig
    pub fn talu_router_iterator_prefill_ns(iterator: *mut c_void) -> u64;
    // core/src/capi/router.zig
    pub fn talu_router_iterator_prompt_tokens(iterator: *mut c_void) -> usize;
    // core/src/capi/router.zig
    pub fn talu_router_result_free(result: *mut CGenerateResult);
    // core/src/capi/validate.zig
    pub fn talu_semantic_validator_check(
        handle: *mut c_void,
        json_str: *const u8,
        json_len: usize,
        out_violation: SemanticViolationC,
    ) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_semantic_validator_create(schema_json: *const c_char) -> *mut c_void;
    // core/src/capi/validate.zig
    pub fn talu_semantic_validator_destroy(handle: *mut c_void);
    // core/src/capi/responses.zig
    pub fn talu_session_id_new(out_session_id: *mut c_void) -> c_int;
    // core/src/capi/log.zig
    pub fn talu_set_log_format(format: c_int);
    // core/src/capi/log.zig
    pub fn talu_set_log_level(level: c_int);
    // core/src/capi/validate.zig
    pub fn talu_set_response_format(
        chat_handle: *mut c_void,
        schema_json: *const c_char,
        config: ValidateConfigC,
        stop_tokens: *const u32,
        stop_tokens_len: usize,
        prefix_token_ids: *const u32,
        prefix_token_ids_len: usize,
    ) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_set_response_format_handle(
        chat_handle: *mut c_void,
        grammar_handle: *mut c_void,
        config: ValidateConfigC,
        stop_tokens: *const u32,
        stop_tokens_len: usize,
        prefix_token_ids: *const u32,
        prefix_token_ids_len: usize,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_add_conversation_tag(
        db_path: *const c_char,
        session_id: *const c_char,
        tag_id: *const c_char,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_create_tag(
        db_path: *const c_char,
        tag_id: *const c_char,
        name: *const c_char,
        color: *const c_char,
        description: *const c_char,
        group_id: *const c_char,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_delete_session(db_path: *const c_char, session_id: *const c_char) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_delete_tag(db_path: *const c_char, tag_id: *const c_char) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_fork_session(
        db_path: *const c_char,
        source_session_id: *const c_char,
        target_item_id: u64,
        new_session_id: *const c_char,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_free_sessions(sessions: *mut CSessionList);
    // core/src/capi/db.zig
    pub fn talu_storage_free_string_list(list: *mut CStringList);
    // core/src/capi/db.zig
    pub fn talu_storage_free_tags(tags: *mut CTagList);
    // core/src/capi/db.zig
    pub fn talu_storage_get_conversation_tags(
        db_path: *const c_char,
        session_id: *const c_char,
        out_tag_ids: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_get_session_info(
        db_path: *const c_char,
        session_id: *const c_char,
        out_session: *mut CSessionRecord,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_get_tag(
        db_path: *const c_char,
        tag_id: *const c_char,
        out_tag: *mut CTagRecord,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_get_tag_by_name(
        db_path: *const c_char,
        name: *const c_char,
        group_id: *const c_char,
        out_tag: *mut CTagRecord,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_get_tag_conversations(
        db_path: *const c_char,
        tag_id: *const c_char,
        out_session_ids: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_list_sessions(
        db_path: *const c_char,
        limit: u32,
        before_updated_at_ms: i64,
        before_session_id: *const c_char,
        group_id: *const c_char,
        search_query: *const c_char,
        tags_filter: *const c_char,
        tags_filter_any: *const c_char,
        out_sessions: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_list_sessions_by_source(
        db_path: *const c_char,
        source_doc_id: *const c_char,
        limit: u32,
        before_updated_at_ms: i64,
        before_session_id: *const c_char,
        out_sessions: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_list_sessions_ex(
        db_path: *const c_char,
        limit: u32,
        before_updated_at_ms: i64,
        before_session_id: *const c_char,
        group_id: *const c_char,
        search_query: *const c_char,
        tags_filter: *const c_char,
        tags_filter_any: *const c_char,
        marker_filter: *const c_char,
        marker_filter_any: *const c_char,
        model_filter: *const c_char,
        created_after_ms: i64,
        created_before_ms: i64,
        updated_after_ms: i64,
        updated_before_ms: i64,
        has_tags: c_int,
        source_doc_id: *const c_char,
        out_sessions: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_list_tags(
        db_path: *const c_char,
        group_id: *const c_char,
        out_tags: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_load_conversation(
        db_path: *const c_char,
        session_id: *const c_char,
    ) -> *mut c_void;
    // core/src/capi/db.zig
    pub fn talu_storage_remove_conversation_tag(
        db_path: *const c_char,
        session_id: *const c_char,
        tag_id: *const c_char,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_update_session(
        db_path: *const c_char,
        session_id: *const c_char,
        title: *const c_char,
        marker: *const c_char,
        metadata_json: *const c_char,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_update_session_ex(
        db_path: *const c_char,
        session_id: *const c_char,
        title: *const c_char,
        marker: *const c_char,
        metadata_json: *const c_char,
        source_doc_id: *const c_char,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_storage_update_tag(
        db_path: *const c_char,
        tag_id: *const c_char,
        name: *const c_char,
        color: *const c_char,
        description: *const c_char,
    ) -> c_int;
    // core/src/capi/error.zig
    pub fn talu_take_last_error(
        out_buf: *const u8,
        out_buf_size: usize,
        out_code: *mut c_void,
    ) -> usize;
    // core/src/capi/template.zig
    pub fn talu_template_render(
        template_str: *const c_char,
        json_vars: *const c_char,
        strict: bool,
        out_rendered: *mut c_void,
    ) -> c_int;
    // core/src/capi/template.zig
    pub fn talu_template_render_debug(
        template_str: *const c_char,
        json_vars: *const c_char,
        strict: bool,
        out_rendered: *mut c_void,
        out_spans: *mut c_void,
        out_span_count: *mut c_void,
    ) -> c_int;
    // core/src/capi/template.zig
    pub fn talu_template_render_with_filters(
        template_str: *const c_char,
        json_vars: *const c_char,
        strict: bool,
        filter_names: *const c_char,
        filter_callbacks: *mut c_void,
        filter_user_data: *mut c_void,
        num_filters: usize,
        out_rendered: *mut c_void,
    ) -> c_int;
    // core/src/capi/template.zig
    pub fn talu_template_validate(
        template_str: *const c_char,
        json_vars: *const c_char,
        out_result_json: *mut c_void,
    ) -> c_int;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_create(
        shape_ptr: *mut c_void,
        ndim: usize,
        dtype: u32,
        device_type: c_int,
        device_id: c_int,
        out_tensor: *mut c_void,
    ) -> c_int;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_data_ptr(t: *mut c_void, out_ptr: *mut c_void) -> c_int;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_device_id(t: *mut c_void) -> c_int;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_device_type(t: *mut c_void) -> c_int;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_dtype(t: *mut c_void) -> u32;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_element_size(t: *mut c_void) -> usize;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_free(tensor: *mut c_void);
    // core/src/capi/tensor.zig
    pub fn talu_tensor_is_cpu(t: *mut c_void) -> bool;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_ndim(t: *mut c_void) -> usize;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_numel(t: *mut c_void) -> usize;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_shape(t: *mut c_void, out_shape: *mut c_void) -> c_int;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_strides(t: *mut c_void, out_strides: *mut c_void) -> c_int;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_test_embeddings(out_tensor: *mut c_void) -> c_int;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_to_dlpack(tensor: *mut c_void, out_dlpack: *mut c_void) -> c_int;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_typestr(t: *mut c_void) -> *const c_char;
    // core/src/capi/tensor.zig
    pub fn talu_tensor_zeros(
        shape_ptr: *mut c_void,
        ndim: usize,
        dtype: u32,
        out_tensor: *mut c_void,
    ) -> c_int;
    // core/src/capi/tokenizer.zig
    pub fn talu_text_free(text: *const c_char);
    // core/src/capi/validate.zig
    pub fn talu_token_mask_apply(
        mask_handle: *mut c_void,
        logits: *const f32,
        logits_len: usize,
    ) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_token_mask_clear(mask_handle: *mut c_void);
    // core/src/capi/validate.zig
    pub fn talu_token_mask_count_valid(mask_handle: *mut c_void) -> usize;
    // core/src/capi/validate.zig
    pub fn talu_token_mask_create(vocab_size: usize) -> *mut c_void;
    // core/src/capi/validate.zig
    pub fn talu_token_mask_destroy(mask_handle: *mut c_void);
    // core/src/capi/validate.zig
    pub fn talu_token_mask_get_bits(mask_handle: *mut c_void) -> *mut c_void;
    // core/src/capi/validate.zig
    pub fn talu_token_mask_get_size(mask_handle: *mut c_void) -> usize;
    // core/src/capi/validate.zig
    pub fn talu_token_mask_get_word_count(mask_handle: *mut c_void) -> usize;
    // core/src/capi/validate.zig
    pub fn talu_token_mask_is_valid(mask_handle: *mut c_void, index: usize) -> bool;
    // core/src/capi/validate.zig
    pub fn talu_token_mask_set(mask_handle: *mut c_void, index: usize);
    // core/src/capi/validate.zig
    pub fn talu_token_mask_set_all(mask_handle: *mut c_void);
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenize_bytes_result_free(
        data: *const u8,
        data_len: usize,
        offsets: *const usize,
        num_tokens: usize,
    );
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenize_result_free(tokens: *const c_char, num_tokens: usize);
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_create(model_path: *const c_char, out_tokenizer: *mut c_void) -> c_int;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_create_from_json(
        json_ptr: *const u8,
        json_len: usize,
        out_tokenizer: *mut c_void,
    ) -> c_int;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_decode(
        handle: *mut c_void,
        tokens: *const u32,
        num_tokens: usize,
        options: DecodeOptionsC,
    ) -> DecodeResult;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_encode(
        handle: *mut c_void,
        text: *const u8,
        text_len: usize,
        options: EncodeOptions,
    ) -> EncodeResult;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_encode_batch(
        handle: *mut c_void,
        texts: *const u8,
        lengths: *const usize,
        num_texts: usize,
        options: EncodeOptions,
    ) -> BatchEncodeResult;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_free(handle: *mut c_void);
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_get_eos_tokens(handle: *mut c_void) -> EosTokenResult;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_get_model_dir(handle: *mut c_void, out_path: *mut c_void) -> c_int;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_get_model_max_length(handle: *mut c_void) -> u64;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_get_special_tokens(handle: *mut c_void) -> SpecialTokensResult;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_get_vocab(handle: *mut c_void) -> VocabResult;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_get_vocab_size(handle: *mut c_void) -> usize;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_id_to_token(
        handle: *mut c_void,
        token_id: c_int,
        out_token: *mut c_void,
    ) -> c_int;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_token_to_id(
        handle: *mut c_void,
        token: *const u8,
        token_len: usize,
    ) -> c_int;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_tokenize(
        handle: *mut c_void,
        text: *const u8,
        text_len: usize,
    ) -> TokenizeResult;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokenizer_tokenize_bytes(
        handle: *mut c_void,
        text: *const u8,
        text_len: usize,
    ) -> TokenizeBytesResult;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokens_concat(
        tokens_a: *const u32,
        num_a: usize,
        tokens_b: *const u32,
        num_b: usize,
    ) -> *const u32;
    // core/src/capi/tokenizer.zig
    pub fn talu_tokens_free(tokens: *const u32, num_tokens: usize);
    // core/src/capi/validate.zig
    pub fn talu_validate_accept(
        handle: *mut c_void,
        token_id: u32,
        token_text: *const c_char,
    ) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_validate_apply(
        handle: *mut c_void,
        tokenizer: *mut c_void,
        logits: *const f32,
        logits_len: usize,
    ) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_validate_create(
        schema_json: *const c_char,
        allow_thinking: bool,
        start_marker: *const c_char,
        stop_tokens: *const u32,
        stop_tokens_len: usize,
    ) -> *mut c_void;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_advance(handle: *mut c_void, bytes: *const u8, len: usize)
        -> usize;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_advance_byte(handle: *mut c_void, byte: u8) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_can_accept(
        handle: *mut c_void,
        bytes: *const u8,
        len: usize,
    ) -> bool;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_count_valid_bytes(handle: *mut c_void) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_create(schema_json: *const c_char) -> *mut c_void;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_destroy(handle: *mut c_void);
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_get_deterministic_continuation(
        handle: *mut c_void,
        out_len: *mut c_void,
    ) -> *const u8;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_get_position(handle: *mut c_void) -> usize;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_get_state_count(handle: *mut c_void) -> usize;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_get_valid_bytes(
        handle: *mut c_void,
        out_valid: *mut c_void,
    ) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_get_valid_tokens(
        handle: *mut c_void,
        vocab_size: usize,
        mask_out: *mut c_void,
        token_fn: *mut c_void,
        ctx: *mut c_void,
    ) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_get_valid_tokens_with_tokenizer(
        handle: *mut c_void,
        tokenizer: *mut c_void,
        mask_out: *mut c_void,
    ) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_is_complete(handle: *mut c_void) -> bool;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_reset(handle: *mut c_void) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_validate_engine_validate(
        handle: *mut c_void,
        bytes: *const u8,
        len: usize,
    ) -> c_int;
    // core/src/capi/validate.zig
    pub fn talu_validate_free(handle: *mut c_void);
    // core/src/capi/validate.zig
    pub fn talu_validate_is_complete(handle: *mut c_void) -> bool;
    // core/src/capi/validate.zig
    pub fn talu_validate_reset(handle: *mut c_void);
    // core/src/capi/validate.zig
    pub fn talu_validate_response_format(
        chat_handle: *mut c_void,
        out_result: SemanticValidationResultC,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_vector_store_append(
        handle: *mut c_void,
        ids_ptr: *mut c_void,
        vectors_ptr: *const f32,
        count: usize,
        dims: u32,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_vector_store_free(handle: *mut c_void);
    // core/src/capi/db.zig
    pub fn talu_vector_store_free_load(
        ids_ptr: *mut c_void,
        vectors_ptr: *const f32,
        count: usize,
        dims: u32,
    );
    // core/src/capi/db.zig
    pub fn talu_vector_store_free_search(
        ids_ptr: *mut c_void,
        scores_ptr: *const f32,
        count: usize,
    );
    // core/src/capi/db.zig
    pub fn talu_vector_store_free_search_batch(
        ids_ptr: *mut c_void,
        scores_ptr: *const f32,
        count_per_query: u32,
        query_count: u32,
    );
    // core/src/capi/db.zig
    pub fn talu_vector_store_init(db_path: *const c_char, out_handle: *mut c_void) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_vector_store_load(
        handle: *mut c_void,
        out_ids: *mut c_void,
        out_vectors: *mut c_void,
        out_count: *mut c_void,
        out_dims: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_vector_store_load_tensor(
        handle: *mut c_void,
        out_ids: *mut c_void,
        out_tensor: *mut c_void,
        out_count: *mut c_void,
        out_dims: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_vector_store_scan(
        handle: *mut c_void,
        query_ptr: *const f32,
        query_len: usize,
        ctx: *mut c_void,
        callback: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_vector_store_scan_batch(
        handle: *mut c_void,
        query_ptr: *const f32,
        query_len: usize,
        dims: u32,
        query_count: u32,
        out_ids: *mut c_void,
        ids_len: usize,
        out_scores: *const f32,
        scores_len: usize,
        out_total_rows: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_vector_store_search(
        handle: *mut c_void,
        query_ptr: *const f32,
        query_len: usize,
        k: u32,
        out_ids: *mut c_void,
        out_scores: *mut c_void,
        out_count: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_vector_store_search_batch(
        handle: *mut c_void,
        query_ptr: *const f32,
        query_len: usize,
        dims: u32,
        query_count: u32,
        k: u32,
        out_ids: *mut c_void,
        out_scores: *mut c_void,
        out_count_per_query: *mut c_void,
    ) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_vector_store_set_durability(handle: *mut c_void, mode: u8) -> c_int;
    // core/src/capi/db.zig
    pub fn talu_vector_store_simulate_crash(handle: *mut c_void);
    // core/src/capi/tokenizer.zig
    pub fn talu_vocab_result_free(
        tokens: *const c_char,
        lengths: *const u32,
        ids: *const u32,
        num_entries: usize,
    );
    // core/src/capi/xray.zig
    pub fn talu_xray_capture_clear(handle: *mut c_void);
    // core/src/capi/xray.zig
    pub fn talu_xray_capture_count(handle: *mut c_void) -> usize;
    // core/src/capi/xray.zig
    pub fn talu_xray_capture_create(points_mask: u32, mode: u8, sample_count: u32) -> *mut c_void;
    // core/src/capi/xray.zig
    pub fn talu_xray_capture_create_all(mode: u8, sample_count: u32) -> *mut c_void;
    // core/src/capi/xray.zig
    pub fn talu_xray_capture_destroy(handle: *mut c_void);
    // core/src/capi/xray.zig
    pub fn talu_xray_capture_disable();
    // core/src/capi/xray.zig
    pub fn talu_xray_capture_enable(handle: *mut c_void);
    // core/src/capi/xray.zig
    pub fn talu_xray_capture_is_enabled() -> bool;
    // core/src/capi/xray.zig
    pub fn talu_xray_capture_overflow(handle: *mut c_void) -> bool;
    // core/src/capi/xray.zig
    pub fn talu_xray_count_matching(
        handle: *mut c_void,
        point: u8,
        layer: u16,
        token: u32,
    ) -> usize;
    // core/src/capi/xray.zig
    pub fn talu_xray_find_anomaly(
        handle: *mut c_void,
        out_point: *mut c_void,
        out_layer: *mut c_void,
        out_token: *mut c_void,
    ) -> bool;
    // core/src/capi/xray.zig
    pub fn talu_xray_get(handle: *mut c_void, index: usize, out: *mut CapturedTensorInfo) -> bool;
    // core/src/capi/xray.zig
    pub fn talu_xray_get_data(
        handle: *mut c_void,
        index: usize,
        out_data: *const u8,
        max_len: usize,
    ) -> usize;
    // core/src/capi/xray.zig
    pub fn talu_xray_get_data_size(handle: *mut c_void, index: usize) -> usize;
    // core/src/capi/xray.zig
    pub fn talu_xray_get_samples(
        handle: *mut c_void,
        index: usize,
        out_samples: *const f32,
        max_samples: usize,
    ) -> usize;
    // core/src/capi/xray.zig
    pub fn talu_xray_point_name(point: u8) -> *const c_char;
}

// =============================================================================
// Safe Helpers
// =============================================================================

/// Safe wrapper for xray capture creation.
pub fn xray_capture_create(points_mask: u32, mode: u8, sample_count: u32) -> *mut c_void {
    unsafe { talu_xray_capture_create(points_mask, mode, sample_count) }
}

/// Safe wrapper for xray capture creation (all points).
pub fn xray_capture_create_all(mode: u8, sample_count: u32) -> *mut c_void {
    unsafe { talu_xray_capture_create_all(mode, sample_count) }
}

/// Safe wrapper to enable xray capture.
pub fn xray_capture_enable(handle: *mut c_void) {
    unsafe { talu_xray_capture_enable(handle) }
}

/// Safe wrapper to disable xray capture.
pub fn xray_capture_disable() {
    unsafe { talu_xray_capture_disable() }
}

/// Safe wrapper to destroy xray capture.
pub fn xray_capture_destroy(handle: *mut c_void) {
    unsafe { talu_xray_capture_destroy(handle) }
}

/// Safe wrapper to get xray capture count.
pub fn xray_capture_count(handle: *mut c_void) -> usize {
    unsafe { talu_xray_capture_count(handle) }
}

/// Safe wrapper to get a captured tensor info entry.
pub fn xray_get(handle: *mut c_void, index: usize, info: &mut CapturedTensorInfo) -> bool {
    unsafe { talu_xray_get(handle, index, info as *mut CapturedTensorInfo) }
}

/// Safe wrapper to get xray point name.
pub fn xray_point_name(point: u8) -> &'static str {
    let ptr = unsafe { talu_xray_point_name(point) };
    if ptr.is_null() {
        "unknown"
    } else {
        unsafe { std::ffi::CStr::from_ptr(ptr) }
            .to_str()
            .unwrap_or("unknown")
    }
}
