use std::env;
use std::fs;
use std::io::Write;
use std::path::PathBuf;

use schemars::schema::Schema;
use schemars::Map;
use typify::{TypeSpace, TypeSpaceSettings};

fn main() {
    let manifest_dir =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set"));
    // bindings/rust/cli -> bindings/rust
    let rust_root = manifest_dir
        .parent()
        .expect("Could not find rust root")
        .to_path_buf();
    // bindings/rust -> bindings -> repo root
    let repo_root = rust_root
        .parent()
        .expect("Could not find bindings dir")
        .parent()
        .expect("Could not find repo root")
        .to_path_buf();

    // --- Bundled UI detection ---
    // Set cfg(bundled_ui) when ui/dist/ contains the required files.
    // This lets http.rs conditionally compile include_bytes!() for the
    // console UI, so a fresh clone without `make ui` still builds.
    let ui_dist = repo_root.join("ui").join("dist");
    println!("cargo:rerun-if-changed={}", ui_dist.display());
    // Track individual UI files so cargo rebuilds when their contents change.
    for file in ["index.html", "main.js", "style.css"] {
        println!("cargo:rerun-if-changed={}", ui_dist.join(file).display());
    }
    println!("cargo:rustc-check-cfg=cfg(bundled_ui)");
    if has_ui_files(&ui_dist) {
        println!("cargo:rustc-cfg=bundled_ui");
    }

    // --- VERSION -> TALU_VERSION ---
    // VERSION file is at bindings/rust/vendor/VERSION (self-contained)
    let version_path = rust_root.join("vendor").join("VERSION");
    println!("cargo:rerun-if-changed={}", version_path.display());

    let content = fs::read_to_string(&version_path).expect("Failed to read vendor/VERSION");
    let version = content.trim();
    let version = if version.is_empty() { "0.0.0" } else { version };
    println!("cargo:rustc-env=TALU_VERSION={}", version);

    // --- OpenAPI -> typify codegen ---
    let openapi_path = manifest_dir.join("src").join("server").join("openapi.json");
    println!("cargo:rerun-if-changed={}", openapi_path.display());

    let openapi_raw = fs::read_to_string(&openapi_path).expect("Failed to read openapi.json");
    let openapi_json: serde_json::Value =
        serde_json::from_str(&openapi_raw).expect("Failed to parse openapi.json");

    let schemas = openapi_json
        .get("components")
        .and_then(|components| components.get("schemas"))
        .and_then(|schemas| schemas.as_object())
        .expect("openapi.json missing components.schemas");

    let mut definitions: Map<String, Schema> = Map::new();
    for (name, schema_value) in schemas {
        let schema: Schema =
            serde_json::from_value(schema_value.clone()).expect("Invalid schema JSON");
        definitions.insert(name.clone(), schema);
    }

    let settings = TypeSpaceSettings::default();
    let mut type_space = TypeSpace::new(&settings);
    type_space
        .add_ref_types(definitions.clone())
        .expect("Failed to add schemas to typify");

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR not set"));
    let out_path = out_dir.join("openapi.rs");

    let mut output = String::new();
    output.push_str("// @generated by build.rs - do not edit\n\n");
    output.push_str(&type_space.to_stream().to_string());

    let mut file = fs::File::create(&out_path).expect("Failed to create openapi.rs");
    file.write_all(output.as_bytes())
        .expect("Failed to write openapi.rs");
}

/// Check whether `ui/dist/` contains any of the required UI files.
fn has_ui_files(dist_path: &std::path::Path) -> bool {
    if !dist_path.is_dir() {
        return false;
    }
    for file in ["index.html", "main.js", "style.css"] {
        if dist_path.join(file).is_file() {
            return true;
        }
    }
    false
}
